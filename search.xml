<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[小米9基于PixelExperience源码编译步骤]]></title>
    <url>%2F2022%2F04%2F28%2Fcepheus%2F</url>
    <content type="text"><![CDATA[Pixel ExperienceSync123456# Initialize local repositoryrepo init -u https://github.com/PixelExperience/manifest -b twelve# Syncrepo sync -c -j$(nproc --all) --force-sync --no-clone-bundle --no-tags Build1234567891011# Set up environment$ . build/envsetup.sh# Choose a target$ lunch aosp_cepheus-userdebug$ lunch aosp_cepheus-user# Build the code$ mka bacon -j4 Turn on caching to speed up buildMake use of ccache if you want to speed up subsequent builds by running:12export USE_CCACHE=1export CCACHE_EXEC=/usr/bin/ccache and adding that line to your ~/.bashrc file. Then, specify the maximum amount of disk space you want ccache to use by typing this: 1ccache -M 50G where 50G corresponds to 50GB of cache. This needs to be run once. Anywhere from 25GB-100GB will result in very noticeably increased build speeds (for instance, a typical 1hr build time can be reduced to 20min). If you’re only building for one device, 25GB-50GB is fine. If you plan to build for several devices that do not share the same kernel source, aim for 75GB-100GB. This space will be permanently occupied on your drive, so take this into consideration. You can also enable the optional ccache compression. While this may involve a slight performance slowdown, it increases the number of files that fit in the cache. To enable it, run:1ccache -o compression=true Start the buildTime to start building! Now, type:12crootmka bacon -j$(nproc --all) Install the buildAssuming the build completed without errors (it will be obvious when it finishes), type the following in the terminal window the build ran in: 1cd $OUT There you’ll find all the files that were created. The two files of more interest are: recovery.img, which is the PixelExperience recovery image. A zip file whose name starts with ‘PixelExperience_’, which is the PixelExperience installer package. Success! So… what’s next?You’ve done it! Welcome to the elite club of self-builders. You’ve built your operating system from scratch, from the ground up. You are the master/mistress of your domain… and hopefully you’ve learned a bit on the way and had some fun too. Submitting PatchesPatches are always welcome! Please submit your patches to our Gerrit. Gerrit push guide 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576unzip platform-tools-latest-linux.zip -d ~# Now you have to add adb and fastboot to your PATH. Open ~/.profile and add the following:# add Android SDK platform tools to pathif [ -d &quot;$HOME/platform-tools&quot; ] ; then PATH=&quot;$HOME/platform-tools:$PATH&quot;ficurl https://storage.googleapis.com/git-repo-downloads/repo &gt; /root/code/twelve/repochmod a+x /root/code/twelve/repocurl https://storage.googleapis.com/git-repo-downloads/repo &gt; /media/psf/aosp/twelve/repochmod a+x /media/psf/aosp/twelve/repo./repo init -u https://github.com/PixelExperience/manifest -b twelverepo init -u https://github.com/PixelExperience/manifest -b twelvegit config --global user.email &quot;xiaoli.xia@uuxiclife.cn&quot;git config --global user.name &quot;uuxia&quot;./repo sync -c -j$(nproc --all) --force-sync --no-clone-bundle --no-tags# Running configuration script:cd ~/git clone https://github.com/akhilnarang/scriptscd scripts./setup/android_build_env.sh./repo sync -c -j$(nproc --all) --force-sync --no-clone-bundle --no-tagssource build/envsetup.shlunch aosp_cepheus-userdebugexport USE_CCACHE=1export CCACHE_EXEC=/usr/bin/ccache# and adding that line to your ~/.bashrc file. Then, specify the maximum amount of disk space you want ccache to use by typing this:ccache -M 50Gccache -o compression=truecrootmka bacon -j$(nproc --all)export http_proxy=http://127.0.0.1:1087export https_proxy=http://127.0.0.1:1087git config --global http.proxy http://127.0.0.1:1087git config --global https.proxy http://127.0.0.1:1087git config --global core.gitproxy http://127.0.0.1:1087export http_proxy=http://127.0.0.1:1080export https_proxy=http://127.0.0.1:1080git config --global http.proxy http://127.0.0.1:1080git config --global https.proxy http://127.0.0.1:1080git config --global core.gitproxy http://127.0.0.1:1080git config --global --get http.proxygit config --global --get https.proxygit config --global --get core.gitproxygit config --global --unset http.proxygit config --global --unset https.proxygit config --global --unset core.gitproxyhttps://mirrors.tuna.tsinghua.edu.cn/git/AOSP/https://android.googlesource.comsudo chown -R root:root /root/cepheus]]></content>
      <tags>
        <tag>cepheus</tag>
        <tag>proxy</tag>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[terminal代理设置]]></title>
    <url>%2F2022%2F04%2F28%2Fproxysetting%2F</url>
    <content type="text"><![CDATA[ubuntu、linux下terminal终端http和git代理设置 #http代理设置(只在当前 shell 生效)12345export http_proxy=http://127.0.0.1:1080export https_proxy=http://127.0.0.1:1080export http_proxy=socks5://127.0.0.1:1087export https_proxy=socks5://127.0.0.1:1087 #http代理查看12echo $http_proxyecho $https_proxy #git代理设置123git config --global http.proxy http://127.0.0.1:1080git config --global https.proxy http://127.0.0.1:1080git config --global core.gitproxy http://127.0.0.1:1080 #查看http、https代理配置情况123git config --global --get http.proxygit config --global --get https.proxygit config --global --get core.gitproxy #取消http、https代理配置123git config --global --unset http.proxygit config --global --unset https.proxygit config --global --unset core.gitproxy 123456789git config --global user.email &quot;xiaoli.xia@clife.cn&quot;git config --global user.name &quot;uuxia&quot;repo init -u https://github.com/PixelExperience/manifest -b twelverepo sync -c -j$(nproc --all) --force-sync --no-clone-bundle --no-tagscd ~/android/perepo init -u https://github.com/PixelExperience/manifest -b twelve]]></content>
      <tags>
        <tag>proxy</tag>
        <tag>git</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汽车搭火教程]]></title>
    <url>%2F2022%2F03%2F24%2Fcar-start%2F</url>
    <content type="text"><![CDATA[汽车搭火教程]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>汽车</tag>
        <tag>搭火</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gradle发布MavenCenter和Nexus私服插件]]></title>
    <url>%2F2022%2F03%2F21%2Fgradle-maven%2F</url>
    <content type="text"><![CDATA[基于Java语言与Gradle Api开发的Gradle Plugin，本Gradle插件可以让你的library发布到MavenCenter和自己的nexus私服变得非常容易。内置了阿里云Maven中央仓库，其中配置了aliyun代理的central、jcenter、google。 一、最新版本(根目录build.gradle)1classpath(&quot;io.github.szhittech:gradle-maven:0.0.9&quot;) 二、功能简介 支持发布多种类型的库, 例如：Java、Android、Kotlin； 支持在新的gradle中依赖方式 api / implementation； 支持签名库资源，包括sources、Javadoc、POM（需要Gradle Version &gt;= 4.8） 本插件内置了signing签名信息与文件(secring.gpg) 三、使用步骤1. 在根目录build.gradle中新增如下代码1classpath(&quot;io.github.szhittech:gradle-maven:0.0.9&quot;) 2. 在library/build.gradle中新增如下代码1apply plugin: &apos;gradle.maven&apos; 四、发布MavenCenter步骤1. 配置根目录下gradle.properties如果发布到MavenCenter，该文件无需配置 2. 配置library/build.gradle1234567891011ext &#123; groupId = &quot;io.github.szhittech&quot; name = &quot;gradle-maven&quot; version = &quot;0.0.0-SNAPSHOT&quot; description = &quot;A Gradle Plugin For Java、Android、Kotlin.&quot; url = &quot;https://e.coding.net/clife-devops/clifepublic/gradle-maven.git&quot; connection = &quot;scm:git@github.com:szhittech/clifesdk.git&quot; authorId = &quot;uuxia&quot; authorName = &quot;xiamoumou&quot; authorEmail = &quot;xxx@clife.com&quot;&#125; 参数 必选 描述 groupId 是 项目组织唯一的标识符 name 是 项目名称 version 是 项目版本。有-SNAPSHOT发布快照，没有发布release版 description 否 项目描述 url 否 项目地址 connection 否 项目地址 authorId 否 作者ID authorName 否 作者姓名 authorEmail 否 作者邮箱 3. 执行发布任务 如上图，点击uploadToMaven，即可将库发布到MavenCenter 发布MavenCenter成功后 Release版步审核步骤如下： 上述步骤成功后，请登录https://s01.oss.sonatype.org/; 页面左侧栏点击Build Promotion-&gt;Staging Repositories； 在Staging Repositories选项卡可以看到刚提交的release版本库，如：iogithubszhittect-xxxx; 勾选iogithubszhittect-xxxx，点击Close； 稍等几十秒 Refresh，再次勾选iogithubszhittect-xxxx，点击Release,即可发布成功，等待大概4小时； 4. 自定Maven oss账号配置因本插件与groupId = &quot;io.github.szhittech&quot;绑定，如果用户需要添加自己的groupid，则需要在gradle.properties配置Maven oss账号 Maven oss账号注册，请至https://s01.oss.sonatype.org/注册 gradle.properties配置如下： 12345maven.name=mavenmaven.username=你的oss账号maven.password=你的oss密码maven.release=https://s01.oss.sonatype.org/service/local/staging/deploy/maven2/maven.snapshot=https://s01.oss.sonatype.org/content/repositories/snapshots/ 五、发布Nexus私服步骤1. 配置根目录下gradle.properties12345nexus.name=codingcoding.username=xiaoli.xia@clife.cncoding.password=xxxxxxcoding.snapshot=https://clife-devops-maven.pkg.coding.net/repository/public-repository/maven-snapshots/coding.release=https://clife-devops-maven.pkg.coding.net/repository/public-repository/maven-releases/ 参数 必选 描述 nexus.name 是 自定义前缀名称，本例coding，下面字段就都以coding为前缀 coding.username 是 私服用户名 coding.password 是 私服密码 coding.snapshot 是 私服快照版上传地址 coding.release 是 私服release版上传地址 2. 配置library/build.gradle1234567891011ext &#123; groupId = &quot;io.github.szhittech&quot; name = &quot;gradle-maven&quot; version = &quot;0.0.0-SNAPSHOT&quot; description = &quot;A Gradle Plugin For Java、Android、Kotlin.&quot; url = &quot;https://e.coding.net/clife-devops/clifepublic/gradle-maven.git&quot; connection = &quot;scm:git@github.com:szhittech/clifesdk.git&quot; authorId = &quot;uuxia&quot; authorName = &quot;xiamoumou&quot; authorEmail = &quot;xxx@clife.cn&quot;&#125; 参数 必选 描述 groupId 是 项目组织唯一的标识符 name 是 项目名称 version 是 项目版本。有-SNAPSHOT发布快照，没有发布release版 description 否 项目描述 url 否 项目地址 connection 否 项目地址 authorId 否 作者ID authorName 否 作者姓名 authorEmail 否 作者邮箱 3. 执行发布任务 如上图，点击uploadToCoding，即可将库发布到Nexus私服 注意：这里的Coding就是上文自定义的前缀(nexus.name) 友情链接： 1. android发布三方库到远程maven仓库详细教程 2. 发布Android Lib到Maven Central]]></content>
      <categories>
        <category>gradle</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>java</tag>
        <tag>gradle</tag>
        <tag>maven</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[netty粘包断包处理]]></title>
    <url>%2F2022%2F02%2F18%2Fnetty-tcp-packet-decoder%2F</url>
    <content type="text"><![CDATA[基于Netty的TCP Server，处理二进制数据断包和粘包，以及tcp发送字符串的截取处理！ 一、5A协议在Netty中处理断包粘包 长度[2] 1 1 设备编码[8] Mac地址[6] 帧序号[4] 保留[8] 命令字[2] Body CRC2[2] 5A 0042 40 00 00000199000B0301 8C18D9FFEB9D 00000046 0000000000000000 0104 0000000001000301000000000000000000000003000200000000000000000000 050B 说明： 1.长度len=0042(HEX)=66=(34+32)不包含5A; 2.空包长度total=35； 3.5A这一个子节不算在len区； int maxFrameLength = 65535; （len是两个子节，所以最大长度是无符号两个子节的最大值） int lengthFieldOffset = 1; （len的索引下表是1，下表从0开始） int lengthFieldLength = 2; （len是两个子节） int lengthAdjustment = -2; （netty从len后面开始读取，5A这一子节又不再len中，len又是2子节，所以这里是-2） int initialBytesToStrip = 0; （这个0表示完整的协议内容，如果不想要5A，那么这里就是1） socketChannel.pipeline().addLast(new LengthFieldBasedFrameDecoder(maxFrameLength, lengthFieldOffset, lengthFieldLength, lengthAdjustment, initialBytesToStrip)); 测试断包发送： 完整数据包：5A0042400000000199000B03018C18D9FFEB9D00000046000000000000000001040000000001000301000000000000000000000003000200000000000000000000050B 第一次发送（一包半）：5A0042400000000199000B03018C18D9FFEB9D00000046000000000000000001040000000001000301000000000000000000000003000200000000000000000000050B 5A0042400000000199000B03018C18D9FFEB9D0000004600000000000000000104 第二次发送（补齐后半包）：0000000001000301000000000000000000000003000200000000000000000000050B 二、水机起始码 功能码 数据长度 Body CRC A2 10 0E 0102030405060708091011121314 050B 说明： 1.len=0E(HEX)=14,这里的len仅仅是Body的长度，不包含head的长度; lengthFieldOffset=2 lengthFieldLength=1 lengthAdjustment=2 initialBytesToStrip=0 maxFrameLength=255 https://blog.csdn.net/lzwglory/article/details/80242209 https://blog.csdn.net/zougen/article/details/79037675 https://www.jianshu.com/p/a0a51fd79f62 https://www.cnblogs.com/workharder/p/12325908.html]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>netty</tag>
        <tag>tcp</tag>
        <tag>server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派设置proxy]]></title>
    <url>%2F2022%2F02%2F14%2Fpi-proxy%2F</url>
    <content type="text"><![CDATA[树莓派设置proxy 设置步骤： 1. cd /etc/apt/apt.conf.d 2. sudo nano 10proxy 3. Acquire::http::Proxy &quot;http://192.168.31.53:1090&quot;; 4. reboot]]></content>
      <categories>
        <category>Raspberry</category>
      </categories>
      <tags>
        <tag>shadowsocks</tag>
        <tag>proxy</tag>
        <tag>raspberry</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git使用SSH进行无密码身份验证]]></title>
    <url>%2F2022%2F02%2F11%2Fgitssh%2F</url>
    <content type="text"><![CDATA[git使用SSH进行无密码身份验证 一、生成keyed25519方式123ssh-keygen -t ed25519 -C &quot;uuxia@uuxia.cn&quot;cat ~/.ssh/id_ed25519.pub rsa方式12ssh-keygen -t rsa -C &quot;uuxia@uuxia.com&quot;cat ~/.ssh/id_rsa.pub 二、测试github1ssh -T git@github.com gitee1ssh -T git@gitee.com coding1ssh -T git@e.coding.net 注意 在个人设置里面添加前，必须删除单独项目中添加的ssh key！！！]]></content>
      <categories>
        <category>Git</category>
        <category>SSH</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
        <tag>gitee</tag>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos服务器程序安装指南]]></title>
    <url>%2F2022%2F02%2F11%2Fcentos-server%2F</url>
    <content type="text"><![CDATA[主要记录我的centos服务器上的服务环境安装，frp、nginx配置、java程序、mysql安装、个人博客hexo。 1. nginx配置123456安装yum install nginx配置代码nano /etc/nginx/nginx.conf nginx.conf12345678910111213141516171819202122232425262728293031323334user root;worker_processes auto;error_log /var/log/nginx/error.log;pid /run/nginx.pid;include /usr/share/nginx/modules/*.conf;events &#123;worker_connections 1024;&#125;http &#123;log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;&apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;&apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; access_log /var/log/nginx/access.log main; sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; client_max_body_size 500m; include /etc/nginx/mime.types; default_type application/octet-stream; include /etc/nginx/conf.d/*.conf;&#125; admin.conf123456789101112131415server &#123; listen 80; server_name admin.uuxia.cn; location / &#123; index index.html index.htm; proxy_set_header Host $host; proxy_pass https://127.0.0.1:8082/; proxy_set_header Upgrade $http_upgrade; proxy_http_version 1.1; proxy_set_header Connection &quot;upgrade&quot;; proxy_redirect https://127.0.0.1/admin https://127.0.0.1:8080/; &#125; &#125; file.conf1234567891011121314151617autoindex on;# 显示目录autoindex_exact_size off;# 显示文件大小autoindex_localtime on;# 显示文件时间server &#123; listen 80; server_name file.uuxia.cn; charset gbk,utf-8; location / &#123; root /home/; index index.html index.htm; charset utf-8; &#125; &#125; cloud.conf1234567891011121314server &#123; listen 80 default_server; server_name cloud.uuxia.cn; location / &#123; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_redirect off; proxy_pass http://127.0.0.1:5212; # 如果您要使用本地存储策略，请将下一行注释符删除，并更改大小为理论最大文件尺寸 # client_max_body_size 20000m; &#125; &#125; java.conf123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151server &#123; listen 80; #listen [::]:80 default_server; server_name uuxia.cn; #root /usr/share/nginx/html; #charset gbk,utf-8;# charset utf-8; location ^~ /frp_server_web/&#123; proxy_set_header X-Real-IP $remote_addr; proxy_set_header Host $http_host; proxy_pass http://127.0.0.1:9090; &#125; location / &#123; root /home/file/xxl6097.github.io; index index.html index.htm; charset utf-8; &#125; location /file &#123; alias /home/file; autoindex on; autoindex_exact_size off; autoindex_localtime on; charset utf-8; &#125; location /websocket&#123; proxy_pass https://127.0.0.1:8082; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &quot;upgrade&quot;; proxy_read_timeout 3600s; &#125; location /admin/ &#123; index index.html index.htm; proxy_set_header Host $host; proxy_pass https://127.0.0.1:8082/; proxy_set_header Upgrade $http_upgrade; proxy_http_version 1.1; proxy_set_header Connection &quot;upgrade&quot;; proxy_redirect https://127.0.0.1/admin https://127.0.0.1:8080/; &#125; location ~* ^(/v2|/webjars|/swagger-resources|/swagger-ui.html)&#123; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $remote_addr; #proxy_set_header Host $host:$server_port; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-Forwarded-Port $server_port; proxy_pass https://127.0.0.1:8082; # 后端服务地址 &#125; location /v1 &#123; proxy_set_header Host $host; add_header &apos;Access-Control-Allow-Origin&apos; &apos;*&apos;; add_header &apos;Access-Control-Allow-Headers&apos; &apos;X-Requested-With&apos;; add_header &apos;Access-Control-Allow-Methods&apos; &apos;GET,POST,OPTIONS&apos;; proxy_pass https://127.0.0.1:8082; &#125; error_page 404 /404.html; location = /40x.html &#123; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; &#125; &#125;# Settings for a TLS enabled server.# server &#123; listen 443 ssl http2 default_server; # listen [::]:443 ssl http2 default_server; server_name uuxia.cn; # root /usr/share/nginx/html; ssl_certificate &quot;/etc/pki/nginx/server.crt&quot;; ssl_certificate_key &quot;/etc/pki/nginx/private/server.key&quot;; ssl_session_cache shared:SSL:1m; ssl_session_timeout 10m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; #ssl_ciphers PROFILE=SYSTEM; ssl_prefer_server_ciphers on;# charset gbk,utf-8; client_max_body_size 500m; location / &#123; root /home/file/xxl6097.github.io; index index.html index.htm; #proxy_pass https://127.0.0.1:8082/; #proxy_redirect https://127.0.0.1/admin https://127.0.0.1:8082/; charset utf-8; &#125; location /file &#123; alias /home/file; autoindex on; autoindex_exact_size off; autoindex_localtime on; charset utf-8; &#125; location /v1 &#123; proxy_set_header Host $host; add_header &apos;Access-Control-Allow-Origin&apos; &apos;*&apos;; add_header &apos;Access-Control-Allow-Headers&apos; &apos;X-Requested-With&apos;; add_header &apos;Access-Control-Allow-Methods&apos; &apos;GET,POST,OPTIONS&apos;; proxy_pass https://127.0.0.1:8082; &#125; location /admin/ &#123; index index.html index.htm; proxy_set_header Host $host; proxy_pass https://127.0.0.1:8082/; proxy_set_header Upgrade $http_upgrade; proxy_http_version 1.1; proxy_set_header Connection &quot;upgrade&quot;; proxy_redirect https://127.0.0.1/admin https://127.0.0.1:8080/; &#125; location ~* ^(/v2|/webjars|/swagger-resources|/swagger-ui.html)&#123; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $remote_addr; #proxy_set_header Host $host:$server_port; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-Forwarded-Port $server_port; proxy_pass https://127.0.0.1:8082; # 后端服务地址 &#125; location /websocket&#123; proxy_pass https://127.0.0.1:8082; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &quot;upgrade&quot;; proxy_read_timeout 3600s; &#125; error_page 404 /404.html; location = /40x.html &#123; &#125;# error_page 500 502 503 504 /50x.html; location = /50x.html &#123; &#125; &#125; 2. mysql安装配置1231.下载MySQLRed Hat Enterprise Linux / Oracle Linux2. 选择 `Red Hat Enterprise Linux 8 / Oracle Linux 8 (x86, 64-bit), RPM Bundle 12345678安装wget https://cdn.mysql.com//Downloads/MySQL-8.0/mysql-8.0.28-1.el8.x86_64.rpm-bundle.tartar -xvf mysql-8.0.28-1.el8.x86_64.rpm-bundle.tar rpm -ivh mysql-community-common-8.0.28-1.el8.x86_64.rpm --nodeps --forcerpm -ivh mysql-community-libs-8.0.28-1.el8.x86_64.rpm --nodeps --forcerpm -ivh mysql-community-client-8.0.28-1.el8.x86_64.rpm --nodeps --forcerpm -ivh mysql-community-server-8.0.28-1.el8.x86_64.rpm --nodeps --force通过 rpm -qa | grep mysql 命令查看 mysql 的安装包 1234567通过以下命令，完成对 mysql 数据库的初始化和相关配置mysqld --initialize;chown mysql:mysql /var/lib/mysql -R;systemctl start mysqld.service;systemctl enable mysqld; 通过 cat /var/log/mysqld.log | grep password 命令查看数据库的密码 通过 mysql -uroot -p 敲回车键进入数据库登陆界面 通过 ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;Xxl2475431305.&#39;; 命令来修改密码ALTER USER &#39;root&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;Xxl2475431305.&#39;;这下密码改成了 root 通过 exit; 命令退出 MySQL，然后通过新密码再次登陆 通过以下命令，进行远程访问的授权12345create user &apos;root&apos;@&apos;%&apos; identified with mysql_native_password by &apos;root&apos;;grant all privileges on *.* to &apos;root&apos;@&apos;%&apos; with grant option;flush privileges; sqlyog链接时出现2058异常 ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;password&#39;;其中password为自己修改的密码。然后SQLyog中重新连接，则可连接成功，OK。 如果报错：ERROR 1396 (HY000): Operation ALTER USER failed for ‘root’@’localhost’则使用下面命令： ALTER USER &#39;root&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;Xxl2475431305.&#39;; 3. JDK安装配置方式一（推荐）1234查询安装的jdk版本yum -y list java*安装jdk1.8yum install -y java-11-openjdk.x86_64 方式二下载12345https://www.oracle.com/java/technologies/downloads/#java8选择 `jdk-8u321-linux-x64.tar.gz`解压 `tar -zxvf jdk-8u321-linux-x64.tar.gz` 12345678修改环境变量 `nano /etc/profile`export JAVA_HOME=/usr/lib/jdk1.8.0_321export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport PATH=$PATH:$JAVA_HOME/binsource /etc/profile 4. gralde安装123456789wget https://services.gradle.org/distributions/gradle-6.7-bin.zipunzip gradle-6.7-bin.zipnano ~/.bash_profilePATH=$PATH:/usr/lib/gradle-6.7/binsource ~/.bash_profile 5. 安装frps安装服务端配置123456789[common]bind_port = 8000token = xxxxxxxxxdashboard_port=8888dashboard_user = admindashboard_pwd = adminvhost_http_port = 9090vhost_https_port = 9091subdomain_host = uuxia.cn 客户端配置12345678910111213141516171819202122232425262728293031323334353637383940[common]tls_enable = trueadmin_addr = 0.0.0.0admin_port = 7400admin_user = adminadmin_pwd = admintoken = xxxxxx#server_addr = 127.0.0.1server_addr = uuxia.cnserver_port = 8000[公司-树莓派3B]type = tcplocal_ip = 0.0.0.0local_port = 22remote_port = 2222[公司-FRP客户端管理页面]type = tcplocal_ip = 0.0.0.0local_port = 7400remote_port = 7401[公司-win]type = tcplocal_ip = 192.168.31.53local_port = 3389remote_port = 7001[公司-iMac-VNC]type = tcplocal_ip = 192.168.31.92local_port = 5900remote_port = 7002[公司-iMac-SSH]type = tcplocal_ip = 192.168.31.92local_port = 22remote_port = 7003 6. 安装Node.js 12341 下载官网地址：https://nodejs.org/en/download/wget https://nodejs.org/dist/v10.24.0/node-v10.24.0-linux-x64.tar.gz 1234567891011安装tar -xvf node-v10.24.0-linux-x64.tar.gzmv node-v10.24.0-linux-x64 /opt/NodejsNODE_HOME=/opt/Nodejsexport PATH=$NODE_HOME/bin:$PATHsource /etc/profilenpm install -g hexo-clinpm uninstall hexo-cli -g 推荐这个，成功卸载 7. 页脚备案代码123456&lt;div style=&quot;color:#666;text-align:center;margin-top:-10px;padding-bottom:35px;&quot;&gt; &lt;p&gt;&lt;a style=&quot;color:#666;&quot; text-decoration:underline;&quot; href=&quot;http://beian.miit.gov.cn/&quot;&gt;工业和信息化部备案管理系统网站 粤ICP备2022014941号&lt;/a&gt;&lt;/p&gt; &lt;p&gt;主办单位：&lt;a style=&quot;color:#666;&quot; text-decoration:underline;&quot; target=&quot;_blank&quot; href=&quot;http://uuxia.cn&quot;&gt;悠悠科技&lt;/a&gt;&lt;/p&gt; &lt;p&gt;Operated by Guangzhou ChoMeng Computer System Co., Ltd.&lt;/p&gt;&lt;/div&gt;]]></content>
      <categories>
        <category>Centos</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>gradle</tag>
        <tag>centos</tag>
        <tag>hexo</tag>
        <tag>frp</tag>
        <tag>nginx</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo写文章使用说明]]></title>
    <url>%2F2022%2F02%2F09%2F%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[如何使用hexo作文章 1. 内容说明123456789---title: hexo写文章使用说明date: 2022-02-09 14:08:49tags: [写作,hexo]categories: hexo---如何使用hexo作文章&lt;!--more--&gt; 2. 新建文章可用Hexo命令创建：1hexo new vpn使用 3. 构建和发布1hexo g -d]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>写作</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[腾讯云【centos】一键安装 shadowsocks-libev]]></title>
    <url>%2F2021%2F09%2F08%2Ftencent-shadowsocks%2F</url>
    <content type="text"><![CDATA[CentOS 7/8 一键安装 shadowsocks-libev, 本教程仅提供学习，请勿用于商业用途和不法行为。 由于 Google BBR 需要内核版本 4.9 以上，如果安装时内核版本低于 4.9 建议先升级内核版本。 提示：CentOS 7 自带内核版本为 3.10，CentOS 8 自带内核版本为 4.18。 查看内核版本命令： uname -r 1、下载脚本一键脚本已集成TCP优化、自动开启Google BBR（限 4.9 或更高版本内核）、自动安装 shadowsocks-libev wget https://down.24kplus.com/linux/shadowsocks/centos-shadowsocks-libev.sh 2、执行脚本进行安装chmod +x centos-shadowsocks-libev.sh &amp;&amp; ./centos-shadowsocks-libev.sh 3、根据shell脚本提示输入相关信息1、提示设置SS密码，输入自定义密码后按回车，也可以直接按回车使用默认密码2、接下来选择SS要使用的服务器端口，输入自己喜欢的端口， 也可以直接按回车使用默认端口3、 然后选择加密方式（仅保留相对安全的加密方式），如果选择chacha20的话，就输入对应序号3，按回车继续4、 安装完成后，会有如下图安装成功的提示，记住各项信息，在客户端连接时需要用到]]></content>
      <categories>
        <category>Centos</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>腾讯云</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[国庆长假新疆旅行-北疆环游]]></title>
    <url>%2F2019%2F10%2F21%2Fxj-north-circle%2F</url>
    <content type="text"><![CDATA[行程速览 注意事项： 日照强烈日夜温差大，做好防晒带好冲锋衣或羽绒服（特别是喀纳斯地区，观鱼亭山顶大风变幻莫测）; 新疆各景点之间距离较远，基本每天换酒店，一次性生活用品带足（建议内裤袜子毛巾也最好买一次性）; 自驾比较随性，建议当天订隔天酒店即可（最好订景区附近城镇，性价比高又干净; 车子油箱少于一半见到加油站就满上; 开车要注意区间限速，哪怕前面一望无际，也只能慢慢的开; 新疆买东西是按公斤计算，吃饭菜量很大，北方人可能没感觉，南方去的点菜要注意量; 治安绝对可靠安全，各种检查，当地百姓纯朴善良（详细后文会说）; 外地卡去新疆只有克拉玛依有4G，其他地区一概没有，建议到新疆第一天办张当地上网卡. D1(9月27号):深圳-乌鲁木齐行程安排： 去酒店放下行李； 时间充足的话，可以去【新疆博物馆】，感怀西域历史的沧桑变化； 如果想要体验感受浓郁异域风情，推荐可以去【二道桥国际大巴扎】，独特的西域文化，琳琅满目的商品及各种新疆特色美食，说不定还能淘到不少好货； 找超市备货； 预定好下一站可可托海的住宿； 注意事项： 晚上21:00以后才会天黑； D2(9月28号):乌鲁木齐-准噶尔盆地-可可苏里湖-可可托海镇行程安排： 途中小镇午餐； 继续北上穿越准噶尔盆地，驶向阿勒泰山腹地； 路经古尔班0烤馕、凉皮、炒面、烤串，地道的羊羔肉; 一路上大概过了十几个安检站 车程： 约520KM（高速、国道为主）; 区间测速80km； 行车路线 D3(9月29号):可可托海镇-可可托海国家地质公园-五彩滩-布尔津费用： 可可托海风景区（门票：90，区间车：36）； 五彩滩景区（门票：50，建议游玩2小时）； 行程安排： 早餐后，前往“世界地质公园”【可可托海国家地质公园】，又称额尔齐斯河大峡谷； 进景区需要办理“边境通行证”，在购票处出示身份证办理即可； 景区车一路沿额尔齐斯河河谷前行； 沿途欣赏金秋的白桦林、石门、夫妻树等，游玩拍摄可可托海著名的标志【神钟山】； 之后可以沿着额尔齐斯河峡谷往里徒步深入一段； 驾车到富蕴县继续大众点评找午餐，午餐后富蕴县——北屯——布尔津——五彩滩； 游览五彩滩景区后返回布尔津，晚餐并游览著名的布尔津美食街； 9点回布尔津市区，入住布尔津国际酒店 注意事项： 进景区需要办理“边境通行证”，在购票处出示身份证办理即可 景区不必走到山顶中蒙边境，后半程风景和前半程类似，另外可以沿中间河边的石子路走，景色更美； 车程： 自驾全程350公里，6小时左右。 布尔津-五彩滩：距离40KM，车程50分钟（此段有区间测速，60）； 富蕴县-布尔津 全程国道，有测速，而且还有流动测速（路边放个临时测速器，CT就停在暗处）； 行车路线 D4(9月30号):布尔津-喀纳斯-贾登峪#####费用： 门票185元/人，门票站到游客中心100元/人，游客中心到观景台120元/人，游船120元/人 行程安排： 布尔津到贾登峪门票站，135公里，区间测速必须要开3个小时； 买喀纳斯景区门票坐景区大巴1小时到游客中心； 在游客中心用餐，然后分头行动，上观鱼台的上观鱼台（要爬1068步梯坎才能到观鱼台，去湖边的去湖边 耍了2个多小时后回游客中心坐大巴出景区； 返程沿途游览三湾（三湾里就月亮湾最为有代表性，另外两个需要清晨漫步才有感觉，这样就必须在喀纳斯景区里住）； 回贾登峪后自驾1个小时前往禾木门票站，转大巴1小时到禾木村入住； 注意事项： 去喀纳斯之前请在布尔津把油箱加满，这来回路上没有加油站 进去喀纳斯一定要裹严实了，冲锋衣羽绒服都穿起来; 区间车要坐在面向车头的右手边，区间车要坐半个小时，右手边会看到山谷，左手边就只能看堡坎了.. 布尔津到喀纳斯后半截的路上，大客车巨多，越往后面山路也最多，安检站也多 车程： 自驾全程135公里，3小时左右。 全程区县测速限速：60km； 去程走大路，返程走小路； 行车路线 D5(10月1号):贾登峪-禾木一日游-禾木村到达禾木村差不多上午10点左右。 费用：行程安排： 上午游览村庄北面的白桦林、草原； 中午回去睡了个午觉； 下午骑马到村庄南面观景台，河边游玩（强烈推荐3小时的美丽峰骑马游，200元/人，其实性价比非常之高，谁骑谁知道）； 傍晚大家可以前往【禾木日落观景台】，俯瞰禾木村全景 晚上，可以干点想干的事。。。 注意事项： 下午4、5点钟的时候太阳巨大巨晒，注意选择时间 车程： 距离70KM，2个半小时车程； 行车路线 D6(10月2号):禾木村-乌尔禾胡杨林-魔鬼城-乌尔禾费用： 门票+观光车 98/人 行程安排： 6点半起床上观景台拍日出，是否能看到晨雾美景就需要点运气了； 驾车回布尔津午餐； 魔鬼城景区里坐小火车一路前行 注意事项： 禾木景区出来的这段景色超美，路边设有多个观景台，可供停车拍照； 魔鬼城合适摄影，特别是日出和日落的时候，景区是24小时开放，但日落要10点过，不要去太早 注意选择时间 乌尔禾，入住博玉大酒店，性价比相当高哦,附近美食也超多; 在马路对面吃到最好吃的一家大盘鸡！还有塔城的特色风干牛肉、特色拉条子; 车程： 禾木-布尔津-克拉玛依：距离470KM，10小时车程（前半段国道有区间测速，后半段高速）； 布尔津-克拉玛依这段横风很大，开车要双手握紧方向盘； 行车路线 D7(10月3号):乌尔禾-果子沟大桥-赛里木湖费用： 门票70一人 行程安排： 中午下道去乌苏市区找大众点评美食（要稍早到达赛里木，后面景点较多，不建议在乌苏就餐）； 大约下午5点才到赛里木湖，环湖一圈玩了3个小时后； 入住果子沟大桥绝佳观景台唯一的山庄； 早点的话，可以上观景台看全景。 注意事项： 可入住龙岭山庄，山顶北可观赛里木湖全景，南可俯揽果子沟大桥全景； 龙岭山庄8点半开始供应早餐 车程： 自驾全程600公里，不耽误只要6个小时； 行车路线 D8(10月4号):赛里木湖-九曲十八弯日落-巴音布鲁克镇费用：行程安排： 早起去拍赛里木湖日出全景； 出发，路径伊犁看薰衣草； 午餐可以在高速服务区用餐； 看巴音布鲁克景区欣赏九曲十八弯的日落 注意事项： 巴音布鲁克景区过了晚上8点不准进； 到达巴音布鲁克镇上，可以入住龙兴国际大酒店 如果到的比较早，那么就今天游玩完巴音布鲁克景点 车程： 自驾全程450公里，7小时左右。 行车路线 D9(10月5号):巴音布鲁克镇-天鹅湖-九曲十八弯-独库公路-乌鲁木齐费用： 景区门票+保险+观光车，170一人 行程安排：1.上午进巴音布鲁克景区游览天鹅湖和九曲十八弯；2.中午在巴音布鲁克镇上撸了本次行程最美味的羊肉串后出发；3.下午：号称中国最美公路的天山天路——独库公路，欣赏沿途一日四季美景；4.直接杀到乌鲁木齐。 注意事项： 晚上8点加油站关门 尽量早点出发，因为去乌鲁木齐有500km，最晚不能超过13点车程： 行车路线 D10(10月6号):乌鲁木齐一日游待定。。。。 D11(10月7号):乌鲁木齐一深圳乌鲁木齐—-飞–深圳 友情链接 【2017自驾游】有一种诗和远方叫新疆！北疆9日环线落地自驾游记 说走就走的北疆自驾十日游（攻略+建议）；]]></content>
      <categories>
        <category>旅行</category>
      </categories>
      <tags>
        <tag>新疆</tag>
        <tag>北疆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[健身运动]]></title>
    <url>%2F2018%2F05%2F21%2Flifehealth%2F</url>
    <content type="text"><![CDATA[健身圈从来就是一个强者的舞台，有的人通过健身强健了体魄，有的人通过健身找到了自信。正所谓“一入健身深似海”，健身就是有这样的魔力让你欲罢不能。 深蹲跳 锻炼部位：股四头肌、腘绳肌、臀大肌、腓肠肌。 俯卧撑 锻炼部位：胸大肌、肱三头肌。 开合跳 锻炼部位：股四头肌、三角肌、比目鱼肌、腓肠肌。 登山者 锻炼部位：股四头肌、腘绳肌、胸肌。 波比跳 锻炼部位：股四头肌、三角肌、腹直肌。 —贵在坚持—]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>运动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派3B(Raspberry 3B)搭建HomeAssistant]]></title>
    <url>%2F2018%2F05%2F02%2Fhomeassistant%2F</url>
    <content type="text"><![CDATA[Home Assistant 是一款基于 Python 的智能家居开源系统，支持众多品牌的智能家居设备，可以轻松实现设备的语音控制、自动化等。本文档全站内容基于 Home Assistant 官方网站 本地化而成，具有以下特点： 整合『组件』与『文档』页，采用更直观清晰、符合中文阅读的展现形式；剔除国内用户较少接触的组件说明，提高常用智能家居平台的层级和权重；跳出 Home Assistant 原生框架，一并纳入 Floorplan、HADashboard 等相关衍生项目；本文将讲述树莓派3B搭建HomeAssistant和小米设备的接入。 一、系统要求和硬件配置 树莓派3B（Raspberry 3B）; 一张16G的TF存储卡； 一台电脑（windowns or mac）； 若干小米设备（小米网关、小米插座、小米吸顶灯等）； TF卡读卡器； 原生 Raspbian 系统； xshell工具； SDFormatter； Win32 Disk Imager。 Etcher Mac版（MacOs下烧录工具）； Fing工具（Android端或者ios端都行）。 二、系统安装 SDFormatter格式化TF存储卡 使用Win32 Disk Imager工具烧录Raspbian系统到TF卡 如果是在MacOs系统下，请用mac自带工具格式化TF卡，然后使用Etcher烧录系统； 三、树莓派配置 烧录完毕后，TF卡自动命名为boot，在boot根目录新建ssh文件以便ss登录； 在TF卡根目录新建wpa_supplicant.conf文件，用于连接WiFi，配置如下： 12345678910country=CNctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdevupdate_config=1network=&#123; ssid=&quot;路由器的ssid&quot; psk=&quot;路由器的密码&quot; key_mgmt=WPA-PSK priority=1&#125; 将TF卡插在树莓派后上电启动； 使用Fing查询树莓派的IP地址； 树莓派默认用户名pi，密码raspberry; 使用xshell连接树莓派，MacOs方式：ssh pi@192.168.x.x -p 22； 3.1 启用root用户（由于本人天性爱自由，所以必须要绝对权限） 设置root用户密码 sudo passwd root 1234pi@raspberrypi:~$ sudo passwd rootEnter new UNIX password: #输入第一遍密码Retype new UNIX password: #输入第二遍密码 启用 root 账号登录 sudo passwd –unlock root 123pi@raspberrypi:~$ sudo passwd --unlock rootpasswd: password expiry information changed. 设置root登陆 sudo nano /etc/ssh/sshd_config 12pi@raspberrypi:~$ sudo nano /etc/ssh/sshd_config Ctrl + W 快捷键 搜索 PermitRootLogin without-password修改 PermitRootLogin without-password 为 PermitRootLogin yes执行完之后，用 reboot 命令重启，这样就可以解锁root账户。 四、HomeAssistant安装 4.1 源替换由于默认都是从国外服务器下载安装，为了避免安装失败所以先替换成阿里的源。 在此目录新建此文件：~/.pip/pip.conf 复制粘贴以下内容并保存： 1234[global]trusted-host=mirrors.aliyun.comindex-url=https://mirrors.aliyun.com/pypi/simple/ 4.2 安装Python3打开Linux系统命令行窗口，输入：sudo apt-get install python3.5 应系统要求输入root账号的密码。 安装资源准备好后提问是否继续安装，打回车确认。然后等待安装完成。 4.3 安装Python3开发资源在第一步安装完成后，继续输入命令：sudo apt-get install python3.5-dev在系统提问是否继续安装时打回车确认。然后等待安装完成。 4.4 安装Pip3继续在命令行中输入：sudo apt install python3-pip回车确认安装。等待安装完成。 4.5 验证安装结果在命令行中输入python3 --version，看到显示版本。在命令行中输入pip3 --version，看到显示版本。说明Python3环境及Pip3工具安装成功。 4.6 使用Pip工具安装Home Assistant在此步之前建议设置国内的安装源，可以提升后续的速度，参见这篇文档。打开命令行窗口，输入：sudo pip3 install homeassistant （此步骤若失败，请重复操作）等待安装过程完成。 4.7 验证安装结果在命令行窗口，输入：hass --debug 参数--debug可以查看启动的日志。首次启动需要初始化配置文件，也会自动下载一些所需的文件，会需要一些时间。有时因网络质量问题还会出现文件下载失败情况，导致启动过程受阻。此时可以关闭命令行窗口，再重新执行启动命令。 继续等待启动过程完成，直到浏览器自动打开Home Assistant系统首页，即表明软件安装成功。 五、HomeAssistant设置自动启动 Home Assistant 针对树莓派的发行版（手动安装除外）中都已经自带自启任务，其余系统安装的用户需要自行配置自启。 5.1 配置自启动文件如果你未使用 Python 虚拟环境安装 Home Assistant，请使用以下方法 sudo nano -w /etc/systemd/system/home-assistant@root.service 复制粘贴 [Unit] Description=Home Assistant After=network-online.target [Service] Type=simple User=%i ExecStart=/usr/local/bin/hass [Install] WantedBy=multi-user.target 注意ExecStart=/usr/local/bin/hass 这个路径使用whereis hass查看路径 5.2 启动自启服务完成上述步骤后，请重新加载进程管理。 sudo systemctl --system daemon-reload 启用服务： sudo systemctl enable home-assistant@root 六、HomeAssistant的一些常用命令 6.1 systemd相关的控制命令sudo systemctl --system daemon-reload：重新加载systemd的配置文件。 sudo systemctl enable home-assistant@root：设置home-assitant服务为自启动。 sudo systemctl disable home-assistant@root：从自启动中去除home-assitant服务。 sudo systemctl start home-assistant@root：手工启动home-assitant服务（命令中start可以替换成stop、restart、status，完成停止、重启、查看服务状态等功能）。 sudo journalctl -f -u home-assistant@root：查看hass的日志输出。 sudo journalctl -f -u home-assistant@[your user] | grep -i &apos;error&apos;：查看hass的日志输出中的error部分 sudo systemctl restart home-assistant@root 6.2 使用脚本控制HomeAssistant#!/bin/bash function check() { echo &quot;检查配置文件是否有错误&quot; sudo hass --script check_config } function dis() { echo &quot;显示所有组件的配置信息&quot; sudo hass --script check_config --info all } function hass() { echo &quot;启动hass&quot; sudo systemctl start home-assistant@root } function rehass() { echo &quot;重启hass&quot; sudo systemctl restart home-assistant@root } function stophass() { echo &quot;停止hass&quot; sudo systemctl stop home-assistant@root } function log(){ echo &quot;查看hass日志&quot; sudo journalctl -f -u home-assistant@root } function debug(){ echo &quot;debug hass&quot; sudo hass --debug } echo &quot;输入编号选择&quot; echo &quot;1. 检查配置文件是否有错误&quot; echo &quot;2. 显示所有组件的配置信息&quot; echo &quot;3. 启动hass&quot; echo &quot;4. 查看hass日志&quot; echo &quot;5. 重启hass&quot; echo &quot;6. 停止hass&quot; echo &quot;7. debug hass&quot; echo &quot;******Enter nothing to exit*****&quot; read num case &quot;$num&quot; in [1] ) (check);; [2] ) (dis);; [3] ) (hass);; [4] ) (log);; [5] ) (rehass);; [6] ) (stophass);; [7] ) (debug);; *) echo &quot;nothing,exit&quot;;; esac 七、小米设备接入 安装米家App（最新版本获取获取不到Token，使用【MI Home5.0.19】此版本OK）; 使用RE文件管理器，打开/data/data/com.xiaomi.smarthome/databases/miio2.db 记录设备的token configuration.yaml配置文件 八、遇到的一些问题 urllib3与chardet不兼容解决方案 1234pip3 uninstall urllib3pip3 uninstall chardetip3 install requests 2.执行sh ./xxx.sh出现：“Syntax error: “(” unexpected”的解决方法 sudo dpkg-reconfigure dash 在选择项中选No，搞定了！ nodejs安装 https://blog.csdn.net/xiongtm/article/details/77620005https://nodejs.org/dist/latest-v9.x/]]></content>
      <categories>
        <category>IoT</category>
      </categories>
      <tags>
        <tag>IoT</tag>
        <tag>HomeAssistant</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos后台运行jar]]></title>
    <url>%2F2018%2F04%2F05%2Fcentos_run_jar%2F</url>
    <content type="text"><![CDATA[jar后台运行 jar后台运行nohup java -jar xx.jar &gt;/dev/null &amp; 此处的“&gt;/dev/null”作用是将终端输出信息输出到空洞中，即不保存输出信息，若要查看输出信息需指定输出到那个文件，例如“&gt;/xxx/yyy.out” 关闭后台进程先查看后台进程pid ps -aux 记住进程pid，然后kill命令关闭 kill [pid]]]></content>
      <categories>
        <category>Centos</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Jar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[业余时间做什么，决定了你的生活品质]]></title>
    <url>%2F2018%2F04%2F04%2Fhobby%2F</url>
    <content type="text"><![CDATA[业余时间做什么，决定了你的生活品质 摄影看到朋友晓川发布的一条动态，配的图特别有意思，以为他去哪里旅行了。 一问才知道，他拍的地方其实只是这座城市一条不起眼的街道。 不由感叹，自己怎么就从来没有发现，这条街道还有这样美的一面。 这或许得益于晓川的摄影素养，他总能从日常生活中，发现不平凡的景致，捕捉稍纵即逝的瞬间。 晓川说，一次偶然，他在某摄影论坛看到了一位摄影师的作品，内心深受触动。 从那以后，从入手第一部相机，到埋头理论书籍，再到拍下自己的第一万零一张照片，他在摄影的道路上一去不复返。 他用镜头记录岁月的流逝，也用这种方式感受生活的诗意和从容。 看晓川相册里的光影世界，无论是花叶建筑，还是人间世故，都能感受到他内心的丰富和细腻。 对摄影爱好的坚持，也让他的生活变得充实丰盈起来。 其实，摄影也好，绘画也好，拥有一些爱好，可以体验不一样的生活方式，不断探索生命的广度和深度。 王小波说，拥有自己的爱好，丰富的内心，再普通的日子也能过出妙趣横生，锦上添花般的诗意。 一个人只注重眼前是不够的，他还应该在生活常态之外，追求更诗意有趣的世界。 而爱好就是你表达自我的最好途径。 美食周末和几个朋友去赏桃花，时近正午，正有些饿了，小美拿出她亲手制作的提拉米苏蛋糕。 席地而坐后，小美还摘了一束粉紫色的野花，用养乐多瓶子插着，顿时感觉增色不少。 小美工作需要三班倒，平时非常忙。但无论如何，她都没有放弃对美食的追求。 休息时，她喜欢变着花样尝试制作不同的美食。 无论是精致的甜点，还是营养的羹汤，或者是可口的料理，她的手艺总能令人惊艳不已。 记得上次一个朋友过生日，小美为她制作了一个蛋糕，裱上了对方喜欢的花样。对方上传朋友圈后，获赞无数。 小美对美食的追求到了极致，有时为了买到最新鲜的食材，她会早起到市场采购。常常一顿饭菜下来，要花去不少时间精力。 但小美一点都没感觉到累，反而觉得这是一种调剂和享受。 当你专心去烹饪美食，并享受其中时，会感觉身边的一切都变得美好起来，仿佛世界都静止了。 吃和思考，都是生命的必需品。 作家朱利安·巴吉尼说，好好吃，就是好好生活。 如果人明白美食真正的价值和本质，就会关注美食带来的生活状态。 美食也有很好的治愈功能，一个人有吃的念头，就有活的欲望。 喜欢美食的人，也通常能把生活过得热气腾腾。 因为他内心怀着对生活的热爱，一餐一饭，都讲究精致。 他会明白，什么才是生活的真实。 运动前段时间，表弟状态有些低迷，整日萎靡不振。 在别人的建议下，他开始跑步。 慢慢坚持下来后，他对待事物的态度开始变得积极，也喜欢上了这个运动。 表弟说，跑步时，我可以不受外界打扰，静下心来思考，反省自己。 有研究表明，人在快乐的时候，大脑会分泌一种叫做内啡肽的物质，而运动会加速这种物质的分泌。 一个坚持运动健身的人，往往也能做到自律、自爱，不会被欲望和情绪左右。 而以有益身心的运动消磨空闲时间的人，生活品质也不会太差。 周国平曾说，排遣的方式，最能见出一个人的性情。 有个朋友，闲暇时光喜欢尝试不同的东西： 比如背古诗文，觉得可以让自己内心沉静； 看各种纪录片，觉得这是了解世界最直观的方式； 还尝试学些入门的乐器，认为音乐给生活带来美好。 培养一些爱好，其实就是学会与自己相处，让一个人的生活变得有声有色。 或许有人认为，这些都是一些无用之事，谈不上兴趣爱好。 其实不然，有味之事，往往无用，并不是所有的爱好都要有用。 哪怕只是定期扔东西，整理房间，也是一种爱好。收拾房间能让心情变好，帮助你认识到什么才是想要的和值得追求的。 正如梁文道所说：读一些无用的书，做一些无用的事，花一些无用的时间，都是为了在一切已知之外，保留一个超越自己的机会，人生中一些很了不起的变化，就是来自这种时刻。 人生在世，总要找到一些专属于你的东西，才能让自己区别于其他人。 如果没有兴趣爱好，就仅仅只是活着而已。 古人云那些爱好广泛的人，其实是对这个世界保持好奇心。 精读君在终身成长词典《63：好奇》里提到：一个有好奇心的人，会思考云彩的形成与变换，会着迷于花蕾的初绽，觉察数学法则逻辑上的简洁性。 他会积极尝试不同事物，学习每一样新东西。 他会懂得欣赏一花一叶的美，也愿意尝试无用之事。 古人云，不为无益之事，何以遣有涯之生？ 你的爱好，就是你庸常生活的寄托，决定你的生活品质。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>hobby</tag>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L2TP/IPSec一键安装脚本]]></title>
    <url>%2F2018%2F04%2F02%2FL2TP-IPSec_sh%2F</url>
    <content type="text"><![CDATA[基于 OpenVZ 虚拟化技术的 VPS 需要开启TUN/TAP才能正常使用，购买 VPS 时请先咨询服务商是否支持开启 TUN/TAP。 OpenVZ 虚拟的 VPS 需要系统内核支持 IPSec 才行。也就是说，母服务器的内核如果不支持的话那就没办法，只能换 VPS。因此，一般不建议在 OpenVZ 的 VPS 上安装本脚本。脚本如果检测到该 VPS 为 OpenVZ 架构，会出现警告提醒。 如何检测是否支持TUN模块？执行命令：cat /dev/net/tun如果返回信息为：cat: /dev/net/tun: File descriptor in bad state 说明正常 如何检测是否支持ppp模块？执行命令：cat /dev/ppp如果返回信息为：cat: /dev/ppp: No such device or address 说明正常当然，脚本在安装时也会执行检查，如果不适用于安装，脚本会予以提示。 本脚本适用环境：系统支持：CentOS6+，Debian7+，Ubuntu12+内存要求：≥128M 更新日期：2017 年 05 月 28 日 关于本脚本：名词解释如下L2TP（Layer 2 Tunneling Protocol）IPSec（Internet Protocol Security）IKEv2 (Internet Key Exchange v2)能实现 IPsec 的目前总体上有 openswan，libreswan，strongswan 这3种。libreswan 是基于 openswan 的 fork，所以现在各个发行版基本已经看不到 openswan 的身影了。当然也有使用 strongswan 的。 之所以要更新 L2TP 一键安装脚本，是因为随着各个 Linux 发行版不断推陈出新，原有的脚本已经不适应现在的需求。本脚本通过编译安装最新版 libreswan 来实现 IPSec（CentOS7 下则是全部 yum 安装），yum 或 apt-get 来安装 xl2tpd，再根据各个发行版的使用方法不同，部署防火墙规则。 使用方法：root 用户登录后，运行以下命令：123wget --no-check-certificate https://raw.githubusercontent.com/teddysun/across/master/l2tp.shchmod +x l2tp.sh./l2tp.sh 执行后，会有如下交互界面 Please input IP-Range:(Default Range: 192.168.18):输入本地IP段范围（本地电脑连接到VPS后给分配的一个本地IP地址），直接回车意味着输入默认值192.168.18 Please input PSK:(Default PSK: teddysun.com):PSK意为预共享密钥，即指定一个密钥将来在连接时需要用到，直接回车意味着输入默认值teddysun.com Please input Username:(Default Username: teddysun):Username意为用户名，即第一个默认用户。直接回车意味着输入默认值teddysun Please input teddysun’s password:(Default Password: Q4SKhu2EXQ):输入用户的密码，默认会随机生成一个10位包含大小写字母和数字的密码，当然你也可以指定密码。 ServerIP:your_server_main_IP显示你的 VPS 的主 IP（如果是多 IP 的 VPS 也只显示一个） Server Local IP:192.168.18.1显示你的 VPS 的本地 IP（默认即可） Client Remote IP Range:192.168.18.2-192.168.18.254显示 IP 段范围 PSK:teddysun.com显示 PSK Press any key to start…or Press Ctrl+c to cancel按下任意按键继续，如果想取消安装，请按Ctrl+c键 安装完成后，脚本会执行 ipsec verify 命令并提示如下： 123456789101112131415If there are no [FAILED] above, then you can connect to yourL2TP VPN Server with the default Username/Password is below:ServerIP:your_server_IPPSK:your PSKUsername:your usenamePassword:your passwordIf you want to modify user settings, please use command(s):l2tp -a (Add a user)l2tp -d (Delete a user)l2tp -l (List all users)l2tp -m (Modify a user password)Welcome to visit https://teddysun.com/448.htmlEnjoy it! 如果你要想对用户进行操作，可以使用如下命令：l2tp -a 新增用户l2tp -d 删除用户l2tp -m 修改现有的用户的密码l2tp -l 列出所有用户名和密码l2tp -h 列出帮助信息 注意事项：1、错误809：解决：路由线路上有防火墙没有关闭（pptp穿透防火墙的能力较差）2、错误代码619解决：123rm -r /dev/pppmknod /dev/ppp c 108 0 然后重启VPS即可。 如果还未解决，尝试重启机器。 3、要根据ppp的版本来选择对应的pptpd版本。ppp-2.4.4 对应 pptpd-1.3.4ppp-2.4.5 对应 pptpd-1.4.0 其他事项：1、脚本在安装完成后，已自动启动进程，并加入了开机自启动。2、脚本会改写 iptables 或 firewalld 的规则。3、脚本安装时，会即时将安装日志写到 /root/l2tp.log 文件里，如果你安装失败，可以通过此文件来寻找错误信息。 使用命令：ipsec status （查看 IPSec 运行状态）ipsec verify （查看 IPSec 检查结果）/etc/init.d/ipsec start|stop|restart|status （CentOS6 下使用）/etc/init.d/xl2tpd start|stop|restart （CentOS6 下使用）systemctl start|stop|restart|status ipsec （CentOS7 下使用）systemctl start|stop|restart xl2tpd （CentOS7 下使用）service ipsec start|stop|restart|status （Debian/Ubuntu 下使用）service xl2tpd start|stop|restart （Debian/Ubuntu 下使用） 更新日志2017 年 05 月 28 日：升级 libreswan 到版本 3.20。修正 libreswan 的若干配置问题。修正 xl2tpd 的端口监听配置问题。修正在 CentOS 6 对 libevent2 的依赖问题，改为 yum 安装 libevent2-devel。测试表明，在内网环境的 VPS 里（如AWS， IDCF，GCE，腾讯云，阿里云等）也可以正常使用了。 2017 年 02 月 25 日：升级 libreswan 到版本 3.19。 2016 年 09 月 12 日：修正了在 CentOS 6 下 libevent2 依赖的问题；新增了一个 -m 选项，用以修改现有用户的密码。 2016 年 08 月 13 日：修正 Debian 8 下的 sd-daemon.h: No such file or directory 问题，是由于缺少依赖包 libsystemd-daemon-dev 导致的。 2016 年 08 月 05 日：升级 libreswan 到版本 3.18。 2016 年 06 月 10 日：脚本在安装完成后，新增了几个命令，便于操作用户l2tp -a 新增用户l2tp -d 删除用户l2tp -l 列出所有用户l2tp -h 列出帮助信息 参考链接：https://libreswan.org/wiki/3.14_on_Debian_Wheezyhttps://github.com/libreswan/libreswan]]></content>
      <categories>
        <category>VPN</category>
      </categories>
      <tags>
        <tag>shadowsocks</tag>
        <tag>翻墙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android导入第三方静态库.a编译成动态库.so]]></title>
    <url>%2F2016%2F05%2F11%2Fandroid-ndk-so-a%2F</url>
    <content type="text"><![CDATA[Android导入第三方静态库.a编译成动态库.so 下面我以一个简单的实际例子来讲解如何在动态库中导入静态库。 静态库中的源代码有两个文件：static.h, static.c，有一个add方法 static.h12345678#include &lt;stdio.h&gt; int add(int x, int y);static.c#include &quot;static.h&quot; int add(int x, int y) &#123; return x + y; &#125; 将它编译成静态库，Android.mk如下： 12345LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS) LOCAL_MODULE := static_add LOCAL_SRC_FILES := static.c include $(BUILD_STATIC_LIBRARY) 注意编译静态库的时候，必须有一个Application.mk文件： APP_MODULES:=static_add APP_MODULES的值应该和Android.mk中的LOCAL_MODULE的值保持一样。 然后调用ndk-build进行编译生成libstatic_add.a静态库 123456789101112hejinlai_iMac:jni hejinlai$ ndk-buildPrebuilt : libstatic_add.a &lt;= jni/ 生成静态库后，然后编写动态库中的源代码: share.h share.c share.h [cpp]#include int test_add(int x, int y);share.c1234567 #include “share.h”#include “static.h”int test_add(int x, int y)&#123;// 调用static里面的方法return add(x, y);&#125; 编写导入静态库的Android.mk：12345678910LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS) LOCAL_MODULE := static_add LOCAL_SRC_FILES := libstatic_add.a include $(PREBUILT_STATIC_LIBRARY) include $(CLEAR_VARS) LOCAL_MODULE := share_add LOCAL_STATIC_LIBRARIES := static_add LOCAL_SRC_FILES := share.c include $(BUILD_SHARED_LIBRARY) 注意上面生成的libstatic_add.a必须跟Android.mk放在同一目录下，否则需要填写相应的路径，然后进行编译：12hejinlai_iMac:jni hejinlai$ ndk-buildCompile thumb : share_add &lt;= share.c Prebuilt : libstatic_add.a &lt;= jni/ SharedLibrary : libshare_add.so Install : libshare_add.so =&gt; libs/armeabi/libshare_add.so 提示so编译成功。 需要注意的是我这边share.c和static.c放在同一目录下，如果放在不同的目录下，需要指定 LOCAL_C_INCLUDES链接到相应的路径。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Andorid</tag>
        <tag>ndk</tag>
        <tag>so</tag>
        <tag>a</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[喜马拉雅WiFi音响绑定及通讯协议初稿]]></title>
    <url>%2F2016%2F05%2F11%2Fximalaya%2F</url>
    <content type="text"><![CDATA[喜马拉雅WiFi音响绑定及通讯协议初稿 通讯协议 0x5A 数据长度 框架版本 协议类型 设备编码 Mac地址 数据帧序列号 保留字 数据类型 数据内容 检验码FCS 1字节 2字节 1字节 1字节 8字节 6字节 4字节 8字节 2字节 N字节 2字节 通讯Json格式：{ &quot;cmd&quot;: 0 ,//命令码 &quot;code&quot;: 0, //返回码 &quot;msg&quot;: &quot;&quot;, //状态消息 &quot;data&quot;: ...... //数据节点 } 参数说明 参数名称 是否必须 字段类型 参数说明 cmd YES int 命令码 code NO int 返回码 msg NO String 状态消息 data NO String 数据节点 全局命令码 每一种操作对用一个命令码，用作标识指令。 全局命令码说明如下： 命令码（十六进制） 十进制 说明 0x0001 1 添加歌曲 0x0002 2 App查询歌曲列表 0x0003 3 升级操作 0x0004 4 播放 0x0005 5 关机 0x0006 6 静音/解除静音 0x0007 7 音量+ 0x0008 8 音量- 0x0009 9 切换aux状态 0x000a 10 下一曲 0x000b 11 上一曲 0x000c 12 暂停 0x000d 13 App查询播放状态 0x000e 14 WIFI 无线简易连接 0x000f 15 设备回复心跳 0x400f 16399 App发送心跳 0x0011 17 palyMode(顺序播放/随机播放/列表循环/单曲循环/) 0x0012 18 音量设置（直接设置音量值） 0x0013 19 设备推送播放状态 0x0014 20 设备推送播放列表 0x0015 21 拖拽进度条 全局返回码 每次调用接口时，可能获得正确或错误的返回码，可以根据返回码信息调试接口，排查错误。 ####全局返回码说明如下：|0| 请求成功||:—–|:—||200| 无错误||400 |不支持此接口||401 |JSON数据解析错误| 示例字符串{ &quot;cmd&quot;: 0x0001 ,//命令码 &quot;code&quot;: 0, //返回码 &quot;msg&quot;: &quot;&quot;, //状态消息 &quot;data&quot;: &quot;This is string&quot; //数据节点 } 整形参数{ &quot;cmd&quot;: 0x0001 ,//命令码 &quot;code&quot;: 0, //返回码 &quot;msg&quot;: &quot;&quot;, //状态消息 &quot;data&quot;: 1 //数据节点 } 对象{ &quot;cmd&quot;: 0x0001 ,//命令码 &quot;code&quot;: 0, //返回码 &quot;msg&quot;: &quot;&quot;, //状态消息 &quot;data&quot;: { &quot;ssid&quot;:&quot;TP-link&quot;, //连接的路由名称 &quot;password&quot;:&quot;12345678&quot;, //路由密码,需要加密 } } 数组{ &quot;cmd&quot;: 0x001 ,//命令码 &quot;code&quot;: 0, //返回码 &quot;msg&quot;: &quot;&quot;, //状态消息 &quot;data&quot;:[ { &quot;id&quot; ： &quot;0&quot; &quot;name&quot; ： “xxxx&quot;, &quot;artist&quot; ： “xxxx&quot;, &quot;album_title&quot;： “xxxx&quot;, &quot;cover_url_small”：“xxxx&quot;, &quot;cover_url_middle&quot;:&quot;xxxx&quot;, &quot;cover_url_large&quot;:&quot;xxxx&quot;, &quot;url&quot;:&quot;xxxxxxxxx&quot; {详细规格见规格说明url部分}, }, { &quot;id&quot;:&quot;1&quot; &quot;name&quot;:&quot;xxxx1&quot;, &quot;artist&quot;:&quot;xxxx1&quot;, &quot;album&quot;:&quot;xxxx1&quot;, &quot;cover_url_small&quot;:&quot;xxxx&quot;, &quot;cover_url_middle&quot;:&quot;xxxx&quot;, &quot;cover_url_large&quot;:&quot;xxxx&quot;, &quot;url&quot;:&quot;xxxxxxxxxx&quot;{详细规格见规格说明url部分}, } ] } 指令说明一、设备基础指令 App扫描设备 0x5A 数据长度 框架版本 协议类型 设备编码 Mac地址 数据帧序列号 保留字 数据类型 数据内容 检验码FCS 5A 0022 40 01 0000000000000000 000000000000 20000000 0000000000000000 0405 data 381a 命令字：0x0405 data区：NULL 设备回复自身信息 0x5A 数据长度 框架版本 协议类型 设备编码 Mac地址 数据帧序列号 保留字 数据类型 数据内容 检验码FCS 5A xxxx 40 01 00000199001b0300 d8f710e019b0 00000000 0000000000000000 0305 data xxxx 命令字：0x0305 厂商ID：0x0199 大分类：0x1b 小分类：0x03 App发送心跳包 0x5A 数据长度 框架版本 协议类型 设备编码 Mac地址 数据帧序列号 保留字 数据类型 数据内容 检验码FCS 5A xxxx 40 01 0000000000000000 000000000000 20000000 0000000000000000 0104 data xxxx 命令字：0x0104 data区：json 示例： { &quot;cmd&quot;: 0x400f ,//命令码 &quot;code&quot;: 0, //返回码 &quot;msg&quot;: &quot;&quot;, //状态消息 &quot;data&quot;: ...... //数据节点 } 设备回复心跳 0x5A 数据长度 框架版本 协议类型 设备编码 Mac地址 数据帧序列号 保留字 数据类型 数据内容 检验码FCS 5A xxxx 40 01 0000000000000000 000000000000 00000000 0000000000000000 0204 data xxxx 命令字：0x0204 data区：json 示例： { &quot;cmd&quot;: 0x000f ,//命令码 &quot;code&quot;: 0, //返回码 &quot;msg&quot;: &quot;&quot;, //状态消息 &quot;data&quot;: { &quot;deviceId&quot;: &quot;SPK设备序列号&quot; } } 二、App主动控制终端指令1.App控制终端 0x5A 数据长度 框架版本 协议类型 设备编码 Mac地址 数据帧序列号 保留字 数据类型 数据内容 检验码FCS 5A xxxx 40 01 0000000000000000 000000000000 00000000 0000000000000000 0104 data xxxx 命令字：0x0104 data区：json数据 示例： { &quot;cmd&quot;: 0x00xx ,//命令码 &quot;code&quot;: 0, //返回码 &quot;msg&quot;: &quot;&quot;, //状态消息 &quot;data&quot;: ...... //数据节点 } 2.终端回复App 0x5A 数据长度 框架版本 协议类型 设备编码 Mac地址 数据帧序列号 保留字 数据类型 数据内容 检验码FCS 5A xxxx 40 01 0000000000000000 000000000000 00000000 0000000000000000 0204 data xxxx 命令字：0x0204 data区：json数据 示例： { &quot;cmd&quot;: 0x00xx ,//命令码 &quot;code&quot;: 0, //返回码 &quot;msg&quot;: &quot;&quot;, //状态消息 &quot;data&quot;: ...... //数据节点 } 三、终端主动发送控制数据给App1.周期上传运行数据 0x5A 数据长度 框架版本 协议类型 设备编码 Mac地址 数据帧序列号 保留字 数据类型 数据内容 检验码FCS 5A xxxx 40 01 0000000000000000 000000000000 00000000 0000000000000000 0105 data xxxx 命令字：0x0105 data区：json数据 示例： 123456&#123; &quot;cmd&quot;: 0x0013 ,//命令码 &quot;code&quot;: 0, //返回码 &quot;msg&quot;: &quot;&quot;, //状态消息 &quot;data&quot;: ...... //数据节点&#125; 音箱数据模型一、歌单参数说明 参数名称 是否必须 字段类型 参数说明 id 是 int 歌曲ID name 否 string 演唱者 artist 否 String 艺术家 album_title 否 String 专辑标题 lrc_id 否 String 歌词ID image_url_small 否 String 歌曲海报1 image_url_middle 否 String 歌曲海报2 image_url_large 否 String 歌曲海报3 mac 否 String Mac地址 total_time 否 int 歌曲时长 album_id 否 int 专辑ID utype 否 int 比如 虾米音乐 考虑 喜马拉雅 之类的 uri 是 int 歌曲URL downloadurl 是 String 下载url 二、播放状态参数说明 参数名称 是否必须 字段类型 参数说明 id 是 int 歌曲ID mtype 是 String 虾米，百度云盘，本地音乐… p_status 否 int “0/1/2/3/4”, //准备播放，播放,暂停,停止,播放结束(用于网络收音机) type 否 String 当前播放源(预设preset),收藏,实时推送 name 否 string 演唱者 artist 否 String 艺术家 album 否 String 专辑 next_id 是 int 下一首歌曲id total_time 是 int 歌曲总时间 current_time 是 int 歌曲当前播放时间 play_mode 否 int 模式（//顺序播放/随机播放列表循环/单曲循环/） volume 是 int 音量 绑定流程 title: 喜马拉雅WiFi音响绑定及通讯协议初稿date: 2016-05-11 22:54:48tags: [智能家居,喜马拉雅,Andorid]categories: [IoT] 喜马拉雅WiFi音响绑定及通讯协议初稿 通讯协议 0x5A 数据长度 框架版本 协议类型 设备编码 Mac地址 数据帧序列号 保留字 数据类型 数据内容 检验码FCS 1字节 2字节 1字节 1字节 8字节 6字节 4字节 8字节 2字节 N字节 2字节 通讯Json格式：{ &quot;cmd&quot;: 0 ,//命令码 &quot;code&quot;: 0, //返回码 &quot;msg&quot;: &quot;&quot;, //状态消息 &quot;data&quot;: ...... //数据节点 } 参数说明 参数名称 是否必须 字段类型 参数说明 cmd YES int 命令码 code NO int 返回码 msg NO String 状态消息 data NO String 数据节点 全局命令码 每一种操作对用一个命令码，用作标识指令。 全局命令码说明如下： 命令码（十六进制) 十进制 说明 0x0001 1 添加歌曲 0x0002 2 App查询歌曲列表 0x0003 3 升级操作 0x0004 4 播放 0x0005 5 关机 0x0006 6 静音/解除静音 0x0007 7 音量+ 0x0008 8 音量- 0x0009 9 切换aux状态 0x000a 10 下一曲 0x000b 11 上一曲 0x000c 12 暂停 0x000d 13 App查询播放状态 0x000e 14 WIFI 无线简易连接 0x000f 15 设备回复心跳 0x400f 16399 App发送心跳 0x0011 17 palyMode(顺序播放/随机播放/列表循环/单曲循环/) 0x0012 18 音量设置（直接设置音量值） 0x0013 19 设备推送播放状态 0x0014 20 设备推送播放列表 0x0015 21 拖拽进度条 全局返回码 每次调用接口时，可能获得正确或错误的返回码，可以根据返回码信息调试接口，排查错误。 ####全局返回码说明如下：|0| 请求成功||:—–|:—||200| 无错误||400 |不支持此接口||401 |JSON数据解析错误| 示例字符串{ &quot;cmd&quot;: 0x0001 ,//命令码 &quot;code&quot;: 0, //返回码 &quot;msg&quot;: &quot;&quot;, //状态消息 &quot;data&quot;: &quot;This is string&quot; //数据节点 } 整形参数{ &quot;cmd&quot;: 0x0001 ,//命令码 &quot;code&quot;: 0, //返回码 &quot;msg&quot;: &quot;&quot;, //状态消息 &quot;data&quot;: 1 //数据节点 } 对象{ &quot;cmd&quot;: 0x0001 ,//命令码 &quot;code&quot;: 0, //返回码 &quot;msg&quot;: &quot;&quot;, //状态消息 &quot;data&quot;: { &quot;ssid&quot;:&quot;TP-link&quot;, //连接的路由名称 &quot;password&quot;:&quot;12345678&quot;, //路由密码,需要加密 } } 数组{ &quot;cmd&quot;: 0x001 ,//命令码 &quot;code&quot;: 0, //返回码 &quot;msg&quot;: &quot;&quot;, //状态消息 &quot;data&quot;:[ { &quot;id&quot; ： &quot;0&quot; &quot;name&quot; ： “xxxx&quot;, &quot;artist&quot; ： “xxxx&quot;, &quot;album_title&quot;： “xxxx&quot;, &quot;cover_url_small”：“xxxx&quot;, &quot;cover_url_middle&quot;:&quot;xxxx&quot;, &quot;cover_url_large&quot;:&quot;xxxx&quot;, &quot;url&quot;:&quot;xxxxxxxxx&quot; {详细规格见规格说明url部分}, }, { &quot;id&quot;:&quot;1&quot; &quot;name&quot;:&quot;xxxx1&quot;, &quot;artist&quot;:&quot;xxxx1&quot;, &quot;album&quot;:&quot;xxxx1&quot;, &quot;cover_url_small&quot;:&quot;xxxx&quot;, &quot;cover_url_middle&quot;:&quot;xxxx&quot;, &quot;cover_url_large&quot;:&quot;xxxx&quot;, &quot;url&quot;:&quot;xxxxxxxxxx&quot;{详细规格见规格说明url部分}, } ] } 指令说明一、设备基础指令 App扫描设备 0x5A 数据长度 框架版本 协议类型 设备编码 Mac地址 数据帧序列号 保留字 数据类型 数据内容 检验码FCS 5A 0022 40 01 0000000000000000 000000000000 20000000 0000000000000000 0405 data 381a 命令字：0x0405 data区：NULL 设备回复自身信息 0x5A 数据长度 框架版本 协议类型 设备编码 Mac地址 数据帧序列号 保留字 数据类型 数据内容 检验码FCS 5A xxxx 40 01 00000199001b0300 d8f710e019b0 00000000 0000000000000000 0305 data xxxx 命令字：0x0305 厂商ID：0x0199 大分类：0x1b 小分类：0x03 App发送心跳包|0x5A |数据长度 |框架版本 |协议类型 |设备编码 |Mac地址 |数据帧序列号 |保留字 |数据类型 |数据内容 |检验码FCS||:—-|:—–|:—–|:—–|:—–|:—–|:—–|:—–|:—–|:—–|:—–||5A |xxxx | 40| 01| 0000000000000000| 000000000000| 20000000| 0000000000000000 |0104| data| xxxx| 命令字：0x0104 data区：json 示例： { &quot;cmd&quot;: 0x400f ,//命令码 &quot;code&quot;: 0, //返回码 &quot;msg&quot;: &quot;&quot;, //状态消息 &quot;data&quot;: ...... //数据节点 } 设备回复心跳 0x5A 数据长度 框架版本 协议类型 设备编码 Mac地址 数据帧序列号 保留字 数据类型 数据内容 检验码FCS 5A xxxx 40 01 0000000000000000 000000000000 00000000 0000000000000000 0204 data xxxx 命令字：0x0204 data区：json 示例： { &quot;cmd&quot;: 0x000f ,//命令码 &quot;code&quot;: 0, //返回码 &quot;msg&quot;: &quot;&quot;, //状态消息 &quot;data&quot;: { &quot;deviceId&quot;: &quot;SPK设备序列号&quot; } } 二、App主动控制终端指令1.App控制终端 0x5A 数据长度 框架版本 协议类型 设备编码 Mac地址 数据帧序列号 保留字 数据类型 数据内容 检验码FCS 5A xxxx 40 01 0000000000000000 000000000000 00000000 0000000000000000 0104 data xxxx 命令字：0x0104 data区：json数据 示例： { &quot;cmd&quot;: 0x00xx ,//命令码 &quot;code&quot;: 0, //返回码 &quot;msg&quot;: &quot;&quot;, //状态消息 &quot;data&quot;: ...... //数据节点 } 2.终端回复App 0x5A 数据长度 框架版本 协议类型 设备编码 Mac地址 数据帧序列号 保留字 数据类型 数据内容 检验码FCS 5A xxxx 40 01 0000000000000000 000000000000 00000000 0000000000000000 0204 data xxxx 命令字：0x0204 data区：json数据 示例： { &quot;cmd&quot;: 0x00xx ,//命令码 &quot;code&quot;: 0, //返回码 &quot;msg&quot;: &quot;&quot;, //状态消息 &quot;data&quot;: ...... //数据节点 } 三、终端主动发送控制数据给App1.周期上传运行数据 0x5A 数据长度 框架版本 协议类型 设备编码 Mac地址 数据帧序列号 保留字 数据类型 数据内容 检验码FCS 5A xxxx 40 01 0000000000000000 000000000000 00000000 0000000000000000 0105 data xxxx 命令字：0x0105 data区：json数据 示例： 123456&#123; &quot;cmd&quot;: 0x0013 ,//命令码 &quot;code&quot;: 0, //返回码 &quot;msg&quot;: &quot;&quot;, //状态消息 &quot;data&quot;: ...... //数据节点&#125; 音箱数据模型一、歌单参数说明 参数名称 是否必须 字段类型 参数说明 id 是 int 歌曲ID name 否 string 演唱者 artist 否 String 艺术家 album_title 否 String 专辑标题 lrc_id 否 String 歌词ID image_url_small 否 String 歌曲海报1 image_url_middle 否 String 歌曲海报2 image_url_large 否 String 歌曲海报3 mac 否 String Mac地址 total_time 否 int 歌曲时长 album_id 否 int 专辑ID utype 否 int 比如 虾米音乐 考虑 喜马拉雅 之类的 uri 是 int 歌曲URL downloadurl 是 String 下载url 二、播放状态参数说明 参数名称 是否必须 字段类型 参数说明 id 是 int 歌曲ID mtype 是 String 虾米，百度云盘，本地音乐… p_status 否 int “0/1/2/3/4”, //准备播放，播放,暂停,停止,播放结束(用于网络收音机) type 否 String 当前播放源(预设preset),收藏,实时推送 name 否 string 演唱者 artist 否 String 艺术家 album 否 String 专辑 next_id 是 int 下一首歌曲id total_time 是 int 歌曲总时间 current_time 是 int 歌曲当前播放时间 play_mode 否 int 模式（//顺序播放/随机播放列表循环/单曲循环/） volume 是 int 音量 绑定流程点击看大图 [原文链接地址]http://blog.csdn.net/xxl6097/article/details/50127949 [原文链接地址]http://blog.csdn.net/xxl6097/article/details/50127949]]></content>
      <categories>
        <category>IoT</category>
      </categories>
      <tags>
        <tag>Andorid</tag>
        <tag>智能家居</tag>
        <tag>喜马拉雅</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[绑定界面动资源画动态替换]]></title>
    <url>%2F2016%2F05%2F11%2Fpublic-bind%2F</url>
    <content type="text"><![CDATA[由于公共模块绑定满足不了TOB项目以及其他项目特殊需求，现对公共模块绑定界面的资源做成可配置，本文介绍一下哪些资源可配置以及如何配置。 颜色配置 颜色的配置需要在res/values，res/values-v14，res/values-v19，res/values-v21等目录下新建 color.xml。 color.xml内容如下： 1234&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;color name=&quot;title_bar_bg_color&quot;&gt;#FFFF4444&lt;/color&gt;&lt;/resources&gt; 目录结构如图1所示 图1 1.标题颜1234&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;color name=&quot;title_bar_bg_color&quot;&gt;填入需要配置的颜色值（#FFFF0000）&lt;/color&gt;&lt;/resources&gt; 2.子分类列表背景色1234&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;color name=&quot;color_app_themes&quot;&gt;填入需要配置的颜色值（#FFFF0000）&lt;/color&gt;&lt;/resources&gt; 绑定动画配置 在主工程res/drawable下分别新建bind_scanning_anim.xml、bind_bouding_anim.xml、bind_failed_anim.xml、bind_sucess_anim.xml资源文件； 1.“扫描中“动画（bind_scanning_anim.xml），代码如下： 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!-- 根标签为animation-list，其中oneshot代表着是否只展示一遍，设置为false会不停的循环播放动画 根标签下，通过item标签对动画中的每一个图片进行声明 android:duration 表示展示所用的该图片的时间长度 --&gt;&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:oneshot=&quot;false&quot;&gt; &lt;item android:drawable=&quot;@drawable/scan1&quot; android:duration=&quot;150&quot;&gt;&lt;/item&gt; &lt;item android:drawable=&quot;@drawable/scan2&quot; android:duration=&quot;150&quot;&gt;&lt;/item&gt;&lt;/animation-list&gt; 扫描中 使用帧动画，默认配置中两帧，即：scan1.png和scan2.png 图片分辨率:201x307 2.绑定中 动画（bind_bouding_anim.xml），代码如下: 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!-- 根标签为animation-list，其中oneshot代表着是否只展示一遍，设置为false会不停的循环播放动画 根标签下，通过item标签对动画中的每一个图片进行声明 android:duration 表示展示所用的该图片的时间长度 --&gt;&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:oneshot=&quot;false&quot;&gt; &lt;item android:drawable=&quot;@drawable/bouding1&quot; android:duration=&quot;150&quot;&gt;&lt;/item&gt; &lt;item android:drawable=&quot;@drawable/bouding2&quot; android:duration=&quot;150&quot;&gt;&lt;/item&gt; &lt;item android:drawable=&quot;@drawable/bouding3&quot; android:duration=&quot;150&quot;&gt;&lt;/item&gt; &lt;item android:drawable=&quot;@drawable/bouding4&quot; android:duration=&quot;150&quot;&gt;&lt;/item&gt; &lt;item android:drawable=&quot;@drawable/bouding5&quot; android:duration=&quot;150&quot;&gt;&lt;/item&gt;&lt;/animation-list&gt; 绑定中 使用帧动画，默认配置使用5帧，即：bouding1.png、bouding2.png、bouding3.png、bouding4.png、bouding5.png 图片分辨率：392x276 3.失败 动画（bind_failed_anim.xml），代码如下： 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!-- 根标签为animation-list，其中oneshot代表着是否只展示一遍，设置为false会不停的循环播放动画 根标签下，通过item标签对动画中的每一个图片进行声明 android:duration 表示展示所用的该图片的时间长度 --&gt;&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:oneshot=&quot;false&quot;&gt; &lt;item android:drawable=&quot;@drawable/failed1&quot; android:duration=&quot;150&quot;&gt;&lt;/item&gt; &lt;item android:drawable=&quot;@drawable/failed2&quot; android:duration=&quot;150&quot;&gt;&lt;/item&gt;&lt;/animation-list&gt; 扫描中 使用帧动画，默认配置使用2帧，即：failed1.png和failed2.png 图片分辨率:203x306 4.成功 动画（bind_sucess_anim.xml），代码如下： 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!-- 根标签为animation-list，其中oneshot代表着是否只展示一遍，设置为false会不停的循环播放动画 根标签下，通过item标签对动画中的每一个图片进行声明 android:duration 表示展示所用的该图片的时间长度 --&gt;&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:oneshot=&quot;false&quot;&gt; &lt;item android:drawable=&quot;@drawable/sucess1&quot; android:duration=&quot;150&quot;&gt;&lt;/item&gt; &lt;item android:drawable=&quot;@drawable/sucess2&quot; android:duration=&quot;150&quot;&gt;&lt;/item&gt;&lt;/animation-list&gt; 扫描中 使用帧动画，默认配置使用2帧，即：sucess1.png和sucess2.png 图片分辨率:203x306 网络请求loadding图标配置在主工程res/drawable下分别新建bind_network_waiting.xml资源文件。代码如下： 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:oneshot=&quot;false&quot;&gt; &lt;item android:drawable=&quot;@drawable/load1&quot; android:duration=&quot;200&quot; /&gt; &lt;item android:drawable=&quot;@drawable/load2&quot; android:duration=&quot;200&quot; /&gt;&lt;/animation-list&gt; 网络请求loadding 使用帧动画，默认配置使用2帧，即：load1.png和load2.png 图片分辨率:126x126 缺省配置如图2： 图2 下拉列表Header动画配置在主工程res/drawable下分别新建bind_droplistview_anim.xml资源文件。代码如下：123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!-- 根标签为animation-list，其中oneshot代表着是否只展示一遍，设置为false会不停的循环播放动画 根标签下，通过item标签对动画中的每一个图片进行声明 android:duration 表示展示所用的该图片的时间长度 --&gt;&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:oneshot=&quot;false&quot;&gt; &lt;item android:drawable=&quot;@drawable/list1&quot; android:duration=&quot;150&quot;&gt;&lt;/item&gt; &lt;item android:drawable=&quot;@drawable/list2&quot; android:duration=&quot;150&quot;&gt;&lt;/item&gt; &lt;item android:drawable=&quot;@drawable/list3&quot; android:duration=&quot;150&quot;&gt;&lt;/item&gt; &lt;item android:drawable=&quot;@drawable/list4&quot; android:duration=&quot;150&quot;&gt;&lt;/item&gt; &lt;item android:drawable=&quot;@drawable/list5&quot; android:duration=&quot;150&quot;&gt;&lt;/item&gt;&lt;/animation-list&gt; 下拉列表Header动画 使用帧动画，默认配置使用5帧，即：list1.png、list2.png、list3.png、list4.png、list5.png 图片分辨率:72x72 缺省配置如图3： 图3]]></content>
      <categories>
        <category>IoT</category>
      </categories>
      <tags>
        <tag>het</tag>
        <tag>智能家居</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS下shadowsocks-libev一键安装脚本]]></title>
    <url>%2F2016%2F05%2F11%2Finstallshadowsocks%2F</url>
    <content type="text"><![CDATA[一键安装 libev 版的 shadowsocks 最新版本。该版本的特点是内存占用小（600k左右），低 CPU 消耗，甚至可以安装在基于 OpenWRT 的路由器上。友情提示：如果你有问题，请先参考这篇《Shadowsocks Troubleshooting》后再问。 系统要求系统支持：CentOS 32或64位内存要求：≥128M日期：2015年08月01日 本脚本适用环境：系统支持：CentOS 32或64位内存要求：≥128M日期：2015年08月01日 关于本脚本：一键安装 libev 版的 shadowsocks 最新版本。该版本的特点是内存占用小（600k左右），低 CPU 消耗，甚至可以安装在基于 OpenWRT 的路由器上。友情提示：如果你有问题，请先参考这篇《Shadowsocks Troubleshooting》后再问。 默认配置：服务器端口：自己设定（如不设定，默认为 8989）客户端端口：1080密码：自己设定（如不设定，默认为teddysun.com） 客户端下载：http://sourceforge.net/projects/shadowsocksgui/files/dist/ 使用方法：使用root用户登录，运行以下命令： 获取安装文件 1wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-libev.sh 设置执行权限 1chmod +x shadowsocks-libev.sh 按照命令 1./shadowsocks-libev.sh 2&gt;&amp;1 | tee shadowsocks-libev.log 安装完成后，脚本提示如下： 12345678910Congratulations, shadowsocks-libev install completed!Your Server IP:your_server_ipYour Server Port:your_server_portYour Password:your_passwordYour Local IP:127.0.0.1Your Local Port:1080Your Encryption Method:aes-256-cfbWelcome to visit:https://teddysun.com/357.htmlEnjoy it! 安装完成后即已后台启动 shadowsocks ，运行 1ps -ef | grep ss-server | grep -v ps | grep -v grep 使用命令 启动：/etc/init.d/shadowsocks start停止：/etc/init.d/shadowsocks stop重启：/etc/init.d/shadowsocks restart查看状态：/etc/init.d/shadowsocks status 卸载方法 1./shadowsocks-libev.sh uninstall 更多版本 shadowsocks 安装 ShadowsocksR 版一键安装脚本（CentOS，Debian，Ubuntu）Shadowsocks Python 版一键安装脚本（CentOS，Debian，Ubuntu）Debian 下 Shadowsocks-libev 一键安装脚本Shadowsocks-go 一键安装脚本（CentOS，Debian，Ubuntu） 更新说明（2015 年 08 月 01 日）：1、新增自定义服务器端口功能（如不设定，默认为 8989）；更新说明（2015 年 04 月 30 日）：1、本脚本会始终安装最新版的 Shadowsocks；2、修改配置文件 /etc/shadowsocks-libev/config.json 同时启用 IPv4 与 IPv6 支持：123456789&#123; &quot;server&quot;:[&quot;[::0]&quot;,&quot;0.0.0.0&quot;], &quot;server_port&quot;:your_server_port, &quot;local_address&quot;:&quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;password&quot;:&quot;your_password&quot;, &quot;timeout&quot;:600, &quot;method&quot;:&quot;aes-256-cfb&quot;&#125; 3、Shadowsocks libev 版不能通过修改配置文件来多端口（只能开启多进程），如果你需要多端口请安装 Python 或 Go 版； 特别说明：1、已安装旧版本的 shadowsocks 需要升级的话，需下载本脚本的最新版，运行卸载命令 ./shadowsocks-libev.sh uninstall然后，再次执行本脚本即可安装最新版。 参考链接：https://github.com/madeye/shadowsocks-libev]]></content>
      <categories>
        <category>VPN</category>
      </categories>
      <tags>
        <tag>shadowsocks</tag>
        <tag>翻墙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ios开发笔记]]></title>
    <url>%2F2016%2F05%2F10%2Fiosdev%2F</url>
    <content type="text"><![CDATA[http://www.williamlong.info/archives/4319.html 证书知识及准备工作 几种开发者帐号区别 真机调试流程 内测发布流程 Appstore 上架流程 目录导航 证书知识及准备工作 基础问题答疑 什么是证书 什么时候需要证书 证书如何获得 如何对代码进行签名 我生成的私钥如何共享给团队成员 各流程中证书的需求情况 模拟器调试 真机调试 打包和发布 消息推送后端服务 开发中常见的证书及相关文件介绍 CSR(certificate request) 文件 开发者证书 apns(Apple Push Notification Service) 证书 p12(Personal Information Exchange) 证书 描述文件(Provisioning Profiles) 附录1: 开发准备相关的网址 几种开发者帐号区别 关键区别 真机调试流程 基本概念 条件和流程 内测发布流程 基本概念 实现条件 几种常见的分发途径 附录2: 常见分发渠道及工具地址 Appstore 上架流程 附录3: App store最新审核标准(2015.3) 证书知识及准备工作基础问题答疑什么是证书由 apple 官方颁发, 用以证明开发者身份的特殊文件, 在 iOS 开发中主要用于代码签名, 保障 iOS 生态的健康安全, 分为开发者证书和发布者证书 什么时候需要证书只有在本机模拟器调试时无需代码签名, 当 App 需要在真机运行和发布时需要使用相应证书进行签名 证书如何获得首先需要拥有相应权限的开发者帐号, 通过在本地生成配对的密钥, 向 provisioning portal 提交公钥后换取, 后续证书在使用时会验证本地私钥 如何对代码进行签名在 xcode 中, 使用描述文件(provision profile 包含调试者证书, 授权设备清单, 应用ID), 在 Build Settings 中选择存于 Keychain Access 中的证书文件设置调试和发布任务时的代码签名 我生成的私钥如何共享给团队成员在 Keychain Access 中找到导入的证书, 右击导出为包含私钥的 Personal Information Exchange(.p12)文件(导出时可以创建密码), 团队成员再导入 p12 证书后就完整包含了证书和私钥 各流程中证书的需求情况模拟器调试不需要 真机调试 描述文件(Provisioning Profiles) 开发者证书(ios_development.cer) 打包和发布 描述文件(Provisioning Profiles) 可用于发布的开发者证书(ios_distribution.cer) 消息推送后端服务 apns 证书 开发中常见的证书及相关文件介绍CSR(certificate request) 文件用于换取证书的公钥文件, 实际是在本地基于 RSA 加密得到配对的密钥, 私钥存于 Keychain Access 用于签名, 公钥作为换取证书的凭证 生成方法 OSX 系统自带的 Keychain Access 选择 “Request a Certificate From a Certificate Authority…” 输入 email 等信息后保存为 .certSigningRequest 文件 命令行下使用 openssl 生成 12$ openssl genrsa -out private.key 2048$ openssl req -new -sha256 -key private.key -out my.certSigningRequest 开发者证书由 apple 官方颁发, 用来证明开发者资格的证书文件, 分开发(ios_development.cer)和发布(ios_distribution.cer)两种 cer 证书跟开发机(私钥)绑定只能在拥有私钥的机器上使用, 如果要迁移机器需要导出为 p12 文件 生成方法在 开发者中心 “certificates” 面板中添加 certificate 并上传刚刚生成的 CSR 文件, 获取 ios_development.cer apns(Apple Push Notification Service) 证书用于服务端消息推送, 类似 ssl 证书使用, 和 App 端的开发打包没有关系 生成方法在 开发者中心 “Identifiers” 面板中添加 App ID 并上传刚刚生成的 CSR 文件, 获取 aps_production.cer p12(Personal Information Exchange) 证书p12 证书实际是包含了 cer 证书及私钥信息, 可以分发给团队成员 生成方法在 Keychain Access 中找到已经导入的 cer 证书, 点右键导出为 p12 格式 描述文件(Provisioning Profiles)包含 certificate appID devices id 的文件用于在 xcode 调试打包时提供授权的配置信息 生成方法 在 开发者中心 “Provisioning Profiles” 面板中添加 iOS Provisioning Profiles 并上传刚刚生成的 CSR 文件, 获取 .mobileprovision 文件 在 xcode 登录开发者帐号后可以连接开发者中心获取 附录1: 开发准备相关的网址 开发者中心https://developer.apple.com/devcenter/ios/index.action iOS 描述管理(配置证书、描述文件、推送服务)https://developer.apple.com/ios/manage/overview/index.action 切换团队(在 web 界面上死活没有找到)https://developer.apple.com/account/selectTeam.action iOS 上架 Appstorehttp://itunesconnect.apple.com/ 几种开发者帐号区别 详见: https://developer.apple.com/programs/start/ios/ 个人(individual) $99/year 公司(company) $99/year 企业(enterprise) $299/year 大学(University) free 关键区别 个人帐号可以真机调试, 发布 appstore, 每年 最多为 100台设备分发 公司帐号和个人帐号类似, 只有这两种帐号可以发布 appstore, 主要特权是可以添加多个开发者子账号, 但只允许主账号提交, 发布等操作, 在协同开发时比较灵活, 可以各自管理授权设备等 企业帐号无法用于 appstore 发布, 但可以不通过 appstore 发布任意 iphone 都可以安装的应用 大学帐号不能发布 appstore, 主要拥有真机调试的权限 真机调试流程基本概念真机调试指 mac 连上 iphone, xcode 可以直接以这台 iphone 设备为 build target, 能在 iphone 里执行编译结果 条件和流程分为拥有独立开发者帐号(也包括公司帐号或企业帐号成员)和共享开发者帐号两种情况 拥有独立开发者帐号 在 provisioning portal 新建应用, 配置授权设备等 开发机上导入证书 在 xcode 上登录开发者帐号, 不需要准备描述文件, xcode 会自动生成(如果是公司帐号可以自动生成 iOS Team Provisioning Profile) 共享开发者帐号如果无法在 xcode 登录一个开发者帐号, 也可以通过他人对你手机和应用 id 的授权, 得到 .mobileprovision 描述文件再导入其含私钥的证书(p12) 即可, 具体步骤如下: 获得手机的 udid (可以连上 mac, 在 itunes 中查看) 告知对方 udid (用以设备授权) 和 应用 id 得到对方生成的证书和描述文件后, 先导入 p12 证书, 再双击 mobileprovision 文件 连接手机, 在 xcode 中选择 build target 为已连接的手机 对刚入门的个人开发者而言, 可以在淘宝搜 iOS真机调试 花几元购买一份授权, 包含(p12 证书 和 .mobileprovision 描述文件) 内测发布流程基本概念当 App 开发进行到一定程度, 需要更多的人参与测试, 需要谋求一种方式方便应用能安装进更多的设备中 实现条件进行内测发布主要的关键点是: 是如何将应用打包为 .ipa xcode6 以后, 个人/公司帐号无法对应用打包为 .ipa, 要么用 xcode5 打包要么拥有企业帐号级别的授权 设备需不需要授权 个人/公司帐号权限只有在 TestFlight / 越狱渠道下完成不授权安装; 企业帐号授权可以在 ad-hoc / in-house 渠道下分发, 完成不授权设备安装 几种常见的分发途径 ad-hoc 打包时必须在登录企业帐号(或其成员)并已导入证书和描述文件的情况下, 任何用户(未授权)都可以在手机上用浏览器访问一个 url(例: itms-services://?action=download-manifest&amp;url=https://example.com/manifest.plist) 完成安装 最大的问题是安装量有 100 的上限, 无法作为一个量很大的分发渠道 in-house 针对企业内部用户进行分发, 相比 ad-hoc 无安装量上限 iOS 8.1.3 开始不能企业证书 Iresign 方式重新签名的应用无法安装https://support.apple.com/en-us/HT204245 TestFlight 仅支持 iOS8.0 以上, 不需要对设备 udid 进行授权, 适合个人 / 公司开发者, 在应用发布前可以开启 TestFlight Beta 测试并添加测试者的 iTunes Connect 帐号, 需要待测用户拥有 iTunes Connect 帐号并在设备安装 TestFlight 客户端 这种方式非常便于推送应用更新和收集测试信息 导出 ipa 包, 越狱安装 如果测试设备都越狱了, 这种方式非常灵活简单, 只有能导出 ipa 包就能通过 itools 等第三方工具安装 附录2: 常见分发渠道及工具地址 fir-第三方应用托管平台http://fir.im/ TestFlighthttps://developer.apple.com/testflight/ Agile-百度内部 ios 分发测试平台http://agile.baidu.com fir-分发相关工具http://fir.im/dev/tools itoolshttp://www.itools.cn/ Appstore 上架流程@TODO 附录3: App store最新审核标准(2015.3) App store最新审核标准(2015.3) 中文翻译 App store最新审核标准(2015.3) 英文原版]]></content>
      <categories>
        <category>Ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OkHttp使用教程]]></title>
    <url>%2F2016%2F05%2F09%2Fokhttphelp%2F</url>
    <content type="text"><![CDATA[这是一个针对技术开发者的一个应用，你可以在掘金上获取最新最优质的技术干货，不仅仅是Android知识、前端、后端以至于产品和设计都有涉猎，想成为全栈工程师的朋友不要错过！ 入门Android系统提供了两种HTTP通信类，HttpURLConnection和HttpClient。关于HttpURLConnection和HttpClient的选择&gt;&gt;官方博客尽管Google在大部分安卓版本中推荐使用HttpURLConnection，但是这个类相比HttpClient实在是太难用，太弱爆了。OkHttp是一个相对成熟的解决方案，据说Android4.4的源码中可以看到HttpURLConnection已经替换成OkHttp实现了。所以我们更有理由相信OkHttp的强大。 OkHttp 处理了很多网络疑难杂症：会从很多常用的连接问题中自动恢复。如果您的服务器配置了多个IP地址，当第一个IP连接失败的时候，OkHttp会自动尝试下一个IP。OkHttp还处理了代理服务器问题和SSL握手失败问题。 使用 OkHttp 无需重写您程序中的网络代码。OkHttp实现了几乎和java.net.HttpURLConnection一样的API。如果你用了 Apache HttpClient，则OkHttp也提供了一个对应的okhttp-apache 模块。 注：在国内使用OkHttp会因为这个问题导致部分酷派手机用户无法联网，所以对于大众app来说，需要等待这个bug修复后再使用。或者尝试使用OkHttp的老版本。截止到目前，OkHttp一直没有修复，并把修复计划延迟到了OkHttp2.3中。不是所有设备都能重现，仅少量设备会出现这个问题。（如果问题这么明显，OkHttp早就修复了） 官方资料官方介绍github源码 使用范围OkHttp支持Android 2.3及其以上版本。对于Java, JDK1.7以上。 jar包准备官方介绍页面有链接位置。这里把下载链接也写在下面。OkHttpOkio 基本使用HTTP GET 12345678OkHttpClient client = new OkHttpClient(); String run(String url) throws IOException &#123; Request request = new Request.Builder().url(url).build(); Response response = client.newCall(request).execute(); if (response.isSuccessful()) &#123; return response.body().string(); &#125; else &#123; throw new IOException(&quot;Unexpected code &quot; + response); &#125;&#125; Request是OkHttp中访问的请求，Builder是辅助类。Response即OkHttp中的响应。Response类： 123public boolean isSuccessful()Returns true if the code is in [200..300), which means the request was successfully received, understood, and accepted. response.body()返回ResponseBody类 1234public final String string() throws IOExceptionReturns the response as a string decoded with the charset of the Content-Type header. If that header is either absent or lacks a charset, this will attempt to decode the response body as UTF-8.Throws:IOException 当然也能获取到流的形式： 1public final InputStream byteStream() HTTP POSTPOST提交Json数据 123456789101112131415public static final MediaType JSON = MediaType.parse(&quot;application/json; charset=utf-8&quot;);OkHttpClient client = new OkHttpClient();String post(String url, String json) throws IOException &#123; RequestBody body = RequestBody.create(JSON, json); Request request = new Request.Builder() .url(url) .post(body) .build(); Response response = client.newCall(request).execute(); f (response.isSuccessful()) &#123; return response.body().string(); &#125; else &#123; throw new IOException(&quot;Unexpected code &quot; + response); &#125;&#125; 使用Request的post方法来提交请求体RequestBody POST提交键值对很多时候我们会需要通过POST方式把键值对数据传送到服务器。 OkHttp提供了很方便的方式来做这件事情。 123456789101112131415161718192021OkHttpClient client = new OkHttpClient();String post(String url, String json) throws IOException &#123; RequestBody formBody = new FormEncodingBuilder() .add(&quot;platform&quot;, &quot;android&quot;) .add(&quot;name&quot;, &quot;bug&quot;) .add(&quot;subject&quot;, &quot;XXXXXXXXXXXXXXX&quot;) .build(); Request request = new Request.Builder() .url(url) .post(body) .build(); Response response = client.newCall(request).execute(); if (response.isSuccessful()) &#123; return response.body().string(); &#125; else &#123; throw new IOException(&quot;Unexpected code &quot; + response); &#125;&#125; 总结通过上面的例子我们可以发现，OkHttp在很多时候使用都是很方便的，而且很多代码也有重复，因此特地整理了下面的工具类。注意： OkHttp官方文档并不建议我们创建多个OkHttpClient，因此全局使用一个。 如果有需要，可以使用clone方法，再进行自定义。这点在后面的高级教程里会提到。 enqueue为OkHttp提供的异步方法，入门教程中并没有提到，后面的高级教程里会有解释。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import java.io.IOException;import java.util.List;import java.util.concurrent.TimeUnit;import org.apache.http.client.utils.URLEncodedUtils;import org.apache.http.message.BasicNameValuePair;import cn.wiz.sdk.constant.WizConstant;import com.squareup.okhttp.Callback;import com.squareup.okhttp.OkHttpClient;import com.squareup.okhttp.Request;import com.squareup.okhttp.Response; public class OkHttpUtil &#123; private static final OkHttpClient mOkHttpClient = new OkHttpClient(); static&#123; mOkHttpClient.setConnectTimeout(30, TimeUnit.SECONDS); &#125; /** * 该不会开启异步线程。 * @param request * @return * @throws IOException */ public static Response execute(Request request) throws IOException&#123; return mOkHttpClient.newCall(request).execute(); &#125; /** * 开启异步线程访问网络 * @param request * @param responseCallback */ public static void enqueue(Request request, Callback responseCallback)&#123; mOkHttpClient.newCall(request).enqueue(responseCallback); &#125; /** * 开启异步线程访问网络, 且不在意返回结果（实现空callback） * @param request */ public static void enqueue(Request request)&#123; mOkHttpClient.newCall(request).enqueue(new Callback() &#123; @Override public void onResponse(Response arg0) throws IOException &#123; &#125; @Override public void onFailure(Request arg0, IOException arg1) &#123; &#125; &#125;); &#125; public static String getStringFromServer(String url) throws IOException&#123; Request request = new Request.Builder().url(url).build(); Response response = execute(request); if (response.isSuccessful()) &#123; String responseUrl = response.body().string(); return responseUrl; &#125; else &#123; throw new IOException(&quot;Unexpected code &quot; + response); &#125; &#125; private static final String CHARSET_NAME = &quot;UTF-8&quot;; /** * 这里使用了HttpClinet的API。只是为了方便 * @param params * @return */ public static String formatParams(List&lt;BasicNameValuePair&gt; params)&#123; return URLEncodedUtils.format(params, CHARSET_NAME); &#125; /** * 为HttpGet 的 url 方便的添加多个name value 参数。 * @param url * @param params * @return */ public static String attachHttpGetParams(String url, List&lt;BasicNameValuePair&gt; params)&#123; return url + &quot;?&quot; + formatParams(params); &#125; /** * 为HttpGet 的 url 方便的添加1个name value 参数。 * @param url * @param name * @param value * @return */ public static String attachHttpGetParam(String url, String name, String value)&#123; return url + &quot;?&quot; + name + &quot;=&quot; + value; &#125;&#125; 高级高级属性其实用的不多，这里主要是对OkHttp github官方教程进行了翻译。 同步get下载一个文件，打印他的响应头，以string形式打印响应体。响应体的 string() 方法对于小文档来说十分方便、高效。但是如果响应体太大（超过1MB），应避免适应 string()方法 ，因为他会将把整个文档加载到内存中。对于超过1MB的响应body，应使用流的方式来处理body。 1234567891011121314151617private final OkHttpClient client = new OkHttpClient(); public void run() throws Exception &#123; Request request = new Request.Builder() .url(&quot;http://publicobject.com/helloworld.txt&quot;) .build(); Response response = client.newCall(request).execute(); if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response); Headers responseHeaders = response.headers(); for (int i = 0; i &lt; responseHeaders.size(); i++) &#123; System.out.println(responseHeaders.name(i) + &quot;: &quot; + responseHeaders.value(i)); &#125; System.out.println(response.body().string());&#125; 异步get在一个工作线程中下载文件，当响应可读时回调Callback接口。读取响应时会阻塞当前线程。OkHttp现阶段不提供异步api来接收响应体。 123456789101112131415161718192021222324private final OkHttpClient client = new OkHttpClient(); public void run() throws Exception &#123; Request request = new Request.Builder() .url(&quot;http://publicobject.com/helloworld.txt&quot;) .build(); client.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Request request, Throwable throwable) &#123; throwable.printStackTrace(); &#125; @Override public void onResponse(Response response) throws IOException &#123; if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response); Headers responseHeaders = response.headers(); for (int i = 0; i &lt; responseHeaders.size(); i++) &#123; System.out.println(responseHeaders.name(i) + &quot;: &quot; + responseHeaders.value(i)); &#125; System.out.println(response.body().string()); &#125; &#125;);&#125; 提取响应头典型的HTTP头 像是一个 Map&lt;String, String&gt; :每个字段都有一个或没有值。但是一些头允许多个值，像Guava的Multimap。例如：HTTP响应里面提供的Vary响应头，就是多值的。OkHttp的api试图让这些情况都适用。当写请求头的时候，使用header(name, value)可以设置唯一的name、value。如果已经有值，旧的将被移除，然后添加新的。使用addHeader(name, value)可以添加多值（添加，不移除已有的）。当读取响应头时，使用header(name)返回最后出现的name、value。通常情况这也是唯一的name、value。如果没有值，那么header(name)将返回null。如果想读取字段对应的所有值，使用headers(name)会返回一个list。为了获取所有的Header，Headers类支持按index访问。 1234567891011121314151617private final OkHttpClient client = new OkHttpClient(); public void run() throws Exception &#123; Request request = new Request.Builder() .url(&quot;https://api.github.com/repos/square/okhttp/issues&quot;) .header(&quot;User-Agent&quot;, &quot;OkHttp Headers.java&quot;) .addHeader(&quot;Accept&quot;, &quot;application/json; q=0.5&quot;) .addHeader(&quot;Accept&quot;, &quot;application/vnd.github.v3+json&quot;) .build(); Response response = client.newCall(request).execute(); if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response); System.out.println(&quot;Server: &quot; + response.header(&quot;Server&quot;)); System.out.println(&quot;Date: &quot; + response.header(&quot;Date&quot;)); System.out.println(&quot;Vary: &quot; + response.headers(&quot;Vary&quot;));&#125; Post方式提交String使用HTTP POST提交请求到服务。这个例子提交了一个markdown文档到web服务，以HTML方式渲染markdown。因为整个请求体都在内存中，因此避免使用此api提交大文档（大于1MB）。 123456789101112131415161718192021222324public static final MediaType MEDIA_TYPE_MARKDOWN = MediaType.parse(&quot;text/x-markdown; charset=utf-8&quot;); private final OkHttpClient client = new OkHttpClient(); public void run() throws Exception &#123; String postBody = &quot;&quot; + &quot;Releases\n&quot; + &quot;--------\n&quot; + &quot;\n&quot; + &quot; * _1.0_ May 6, 2013\n&quot; + &quot; * _1.1_ June 15, 2013\n&quot; + &quot; * _1.2_ August 11, 2013\n&quot;; Request request = new Request.Builder() .url(&quot;https://api.github.com/markdown/raw&quot;) .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, postBody)) .build(); Response response = client.newCall(request).execute(); if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response); System.out.println(response.body().string());&#125; Post方式提交流以流的方式POST提交请求体。请求体的内容由流写入产生。这个例子是流直接写入Okio的BufferedSink。你的程序可能会使用OutputStream，你可以使用BufferedSink.outputStream()来获取。 1234567891011121314151617181920212223242526272829303132333435363738public static final MediaType MEDIA_TYPE_MARKDOWN = MediaType.parse(&quot;text/x-markdown; charset=utf-8&quot;); private final OkHttpClient client = new OkHttpClient(); public void run() throws Exception &#123; RequestBody requestBody = new RequestBody() &#123; @Override public MediaType contentType() &#123; return MEDIA_TYPE_MARKDOWN; &#125; @Override public void writeTo(BufferedSink sink) throws IOException &#123; sink.writeUtf8(&quot;Numbers\n&quot;); sink.writeUtf8(&quot;-------\n&quot;); for (int i = 2; i &lt;= 997; i++) &#123; sink.writeUtf8(String.format(&quot; * %s = %s\n&quot;, i, factor(i))); &#125; &#125; private String factor(int n) &#123; for (int i = 2; i &lt; n; i++) &#123; int x = n / i; if (x * i == n) return factor(x) + &quot; × &quot; + i; &#125; return Integer.toString(n); &#125; &#125;; Request request = new Request.Builder() .url(&quot;https://api.github.com/markdown/raw&quot;) .post(requestBody) .build(); Response response = client.newCall(request).execute(); if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response); System.out.println(response.body().string());&#125; Post方式提交文件以文件作为请求体是十分简单的。 123456789101112131415161718public static final MediaType MEDIA_TYPE_MARKDOWN = MediaType.parse(&quot;text/x-markdown; charset=utf-8&quot;); private final OkHttpClient client = new OkHttpClient(); public void run() throws Exception &#123; File file = new File(&quot;README.md&quot;); Request request = new Request.Builder() .url(&quot;https://api.github.com/markdown/raw&quot;) .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, file)) .build(); Response response = client.newCall(request).execute(); if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response); System.out.println(response.body().string());&#125; Post方式提交表单使用FormEncodingBuilder来构建和HTML标签相同效果的请求体。键值对将使用一种HTML兼容形式的URL编码来进行编码。 12345678910111213141516private final OkHttpClient client = new OkHttpClient(); public void run() throws Exception &#123; RequestBody formBody = new FormEncodingBuilder() .add(&quot;search&quot;, &quot;Jurassic Park&quot;) .build(); Request request = new Request.Builder() .url(&quot;https://en.wikipedia.org/w/index.php&quot;) .post(formBody) .build(); Response response = client.newCall(request).execute(); if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response); System.out.println(response.body().string());&#125; Post方式提交分块请求MultipartBuilder可以构建复杂的请求体，与HTML文件上传形式兼容。多块请求体中每块请求都是一个请求体，可以定义自己的请求头。这些请求头可以用来描述这块请求，例如他的Content-Disposition。如果Content-Length和Content-Type可用的话，他们会被自动添加到请求头中。 12345678910111213141516171819202122232425262728private static final String IMGUR_CLIENT_ID = &quot;...&quot;;private static final MediaType MEDIA_TYPE_PNG = MediaType.parse(&quot;image/png&quot;); private final OkHttpClient client = new OkHttpClient(); public void run() throws Exception &#123; // Use the imgur image upload API as documented at https://api.imgur.com/endpoints/image RequestBody requestBody = new MultipartBuilder() .type(MultipartBuilder.FORM) .addPart( Headers.of(&quot;Content-Disposition&quot;, &quot;form-data; name=\&quot;title\&quot;&quot;), RequestBody.create(null, &quot;Square Logo&quot;)) .addPart( Headers.of(&quot;Content-Disposition&quot;, &quot;form-data; name=\&quot;image\&quot;&quot;), RequestBody.create(MEDIA_TYPE_PNG, new File(&quot;website/static/logo-square.png&quot;))) .build(); Request request = new Request.Builder() .header(&quot;Authorization&quot;, &quot;Client-ID &quot; + IMGUR_CLIENT_ID) .url(&quot;https://api.imgur.com/3/image&quot;) .post(requestBody) .build(); Response response = client.newCall(request).execute(); if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response); System.out.println(response.body().string());&#125; 使用Gson来解析JSON响应Gson是一个在JSON和Java对象之间转换非常方便的api。这里我们用Gson来解析Github API的JSON响应。注意：ResponseBody.charStream()使用响应头Content-Type指定的字符集来解析响应体。默认是UTF-8。 123456789101112131415161718192021222324private final OkHttpClient client = new OkHttpClient();private final Gson gson = new Gson(); public void run() throws Exception &#123; Request request = new Request.Builder() .url(&quot;https://api.github.com/gists/c2a7c39532239ff261be&quot;) .build(); Response response = client.newCall(request).execute(); if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response); Gist gist = gson.fromJson(response.body().charStream(), Gist.class); for (Map.Entry&lt;String, GistFile&gt; entry : gist.files.entrySet()) &#123; System.out.println(entry.getKey()); System.out.println(entry.getValue().content); &#125;&#125; static class Gist &#123; Map&lt;String, GistFile&gt; files;&#125; static class GistFile &#123; String content;&#125; 响应缓存为了缓存响应，你需要一个你可以读写的缓存目录，和缓存大小的限制。这个缓存目录应该是私有的，不信任的程序应不能读取缓存内容。一个缓存目录同时拥有多个缓存访问是错误的。大多数程序只需要调用一次new OkHttp()，在第一次调用时配置好缓存，然后其他地方只需要调用这个实例就可以了。否则两个缓存示例互相干扰，破坏响应缓存，而且有可能会导致程序崩溃。响应缓存使用HTTP头作为配置。你可以在请求头中添加Cache-Control: max-stale=3600 ,OkHttp缓存会支持。你的服务通过响应头确定响应缓存多长时间，例如使用Cache-Control: max-age=9600。 123456789101112131415161718192021222324252627282930313233private final OkHttpClient client; public CacheResponse(File cacheDirectory) throws Exception &#123; int cacheSize = 10 * 1024 * 1024; // 10 MiB Cache cache = new Cache(cacheDirectory, cacheSize); client = new OkHttpClient(); client.setCache(cache);&#125; public void run() throws Exception &#123; Request request = new Request.Builder() .url(&quot;http://publicobject.com/helloworld.txt&quot;) .build(); Response response1 = client.newCall(request).execute(); if (!response1.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response1); String response1Body = response1.body().string(); System.out.println(&quot;Response 1 response: &quot; + response1); System.out.println(&quot;Response 1 cache response: &quot; + response1.cacheResponse()); System.out.println(&quot;Response 1 network response: &quot; + response1.networkResponse()); Response response2 = client.newCall(request).execute(); if (!response2.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response2); String response2Body = response2.body().string(); System.out.println(&quot;Response 2 response: &quot; + response2); System.out.println(&quot;Response 2 cache response: &quot; + response2.cacheResponse()); System.out.println(&quot;Response 2 network response: &quot; + response2.networkResponse()); System.out.println(&quot;Response 2 equals Response 1? &quot; + response1Body.equals(response2Body));&#125; 扩展在这一节还提到了下面一句：There are cache headers to force a cached response, force a network response, or force the network response to be validated with a conditional GET. 我不是很懂cache，平时用到的也不多，所以把Google在Android Developers一段相关的解析放到这里吧。 Force a Network ResponseIn some situations, such as after a user clicks a ‘refresh’ button, it may be necessary to skip the cache, and fetch data directly from the server. To force a full refresh, add the no-cache directive: connection.addRequestProperty(“Cache-Control”, “no-cache”); If it is only necessary to force a cached response to be validated by the server, use the more efficient max-age=0 instead: connection.addRequestProperty(“Cache-Control”, “max-age=0”); ##Force a Cache ResponseSometimes you’ll want to show resources if they are available immediately, but not otherwise. This can be used so your application can show something while waiting for the latest data to be downloaded. To restrict a request to locally-cached resources, add the only-if-cached directive: 12345678try &#123; connection.addRequestProperty(&quot;Cache-Control&quot;, &quot;only-if-cached&quot;); InputStream cached = connection.getInputStream(); // the resource was cached! show it catch (FileNotFoundException e) &#123; // the resource was not cached &#125;&#125; This technique works even better in situations where a stale response is better than no response. To permit stale cached responses, use the max-stale directive with the maximum staleness in seconds: 1int maxStale = 60 * 60 * 24 * 28; // tolerate 4-weeks staleconnection.addRequestProperty(&quot;Cache-Control&quot;, &quot;max-stale=&quot; + maxStale); 以上信息来自：HttpResponseCache - Android SDK | Android Developers 取消一个Call使用Call.cancel()可以立即停止掉一个正在执行的call。如果一个线程正在写请求或者读响应，将会引发IOException。当call没有必要的时候，使用这个api可以节约网络资源。例如当用户离开一个应用时。不管同步还是异步的call都可以取消。你可以通过tags来同时取消多个请求。当你构建一请求时，使用RequestBuilder.tag(tag)来分配一个标签。之后你就可以用OkHttpClient.cancel(tag)来取消所有带有这个tag的call。 123456789101112131415161718192021222324252627282930private final ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);private final OkHttpClient client = new OkHttpClient(); public void run() throws Exception &#123; Request request = new Request.Builder() .url(&quot;http://httpbin.org/delay/2&quot;) // This URL is served with a 2 second delay. .build(); final long startNanos = System.nanoTime(); final Call call = client.newCall(request); // Schedule a job to cancel the call in 1 second. executor.schedule(new Runnable() &#123; @Override public void run() &#123; System.out.printf(&quot;%.2f Canceling call.%n&quot;, (System.nanoTime() - startNanos) / 1e9f); call.cancel(); System.out.printf(&quot;%.2f Canceled call.%n&quot;, (System.nanoTime() - startNanos) / 1e9f); &#125; &#125;, 1, TimeUnit.SECONDS); try &#123; System.out.printf(&quot;%.2f Executing call.%n&quot;, (System.nanoTime() - startNanos) / 1e9f); Response response = call.execute(); System.out.printf(&quot;%.2f Call was expected to fail, but completed: %s%n&quot;, (System.nanoTime() - startNanos) / 1e9f, response); &#125; catch (IOException e) &#123; System.out.printf(&quot;%.2f Call failed as expected: %s%n&quot;, (System.nanoTime() - startNanos) / 1e9f, e); &#125;&#125; 超时没有响应时使用超时结束call。没有响应的原因可能是客户点链接问题、服务器可用性问题或者这之间的其他东西。OkHttp支持连接，读取和写入超时 1234567891011121314151617private final OkHttpClient client; public ConfigureTimeouts() throws Exception &#123; client = new OkHttpClient(); client.setConnectTimeout(10, TimeUnit.SECONDS); client.setWriteTimeout(10, TimeUnit.SECONDS); client.setReadTimeout(30, TimeUnit.SECONDS);&#125; public void run() throws Exception &#123; Request request = new Request.Builder() .url(&quot;http://httpbin.org/delay/2&quot;) // This URL is served with a 2 second delay. .build(); Response response = client.newCall(request).execute(); System.out.println(&quot;Response completed: &quot; + response);&#125; 每个call的配置使用OkHttpClient，所有的HTTP Client配置包括代理设置、超时设置、缓存设置。当你需要为单个call改变配置的时候，clone 一个 OkHttpClient。这个api将会返回一个浅拷贝（shallow copy），你可以用来单独自定义。下面的例子中，我们让一个请求是500ms的超时、另一个是3000ms的超时。 123456789101112131415161718192021222324252627private final OkHttpClient client = new OkHttpClient(); public void run() throws Exception &#123; Request request = new Request.Builder() .url(&quot;http://httpbin.org/delay/1&quot;) // This URL is served with a 1 second delay. .build(); try &#123; Response response = client.clone() // Clone to make a customized OkHttp for this request. .setReadTimeout(500, TimeUnit.MILLISECONDS) .newCall(request) .execute(); System.out.println(&quot;Response 1 succeeded: &quot; + response); &#125; catch (IOException e) &#123; System.out.println(&quot;Response 1 failed: &quot; + e); &#125; try &#123; Response response = client.clone() // Clone to make a customized OkHttp for this request. .setReadTimeout(3000, TimeUnit.MILLISECONDS) .newCall(request) .execute(); System.out.println(&quot;Response 2 succeeded: &quot; + response); &#125; catch (IOException e) &#123; System.out.println(&quot;Response 2 failed: &quot; + e); &#125;&#125; 处理验证这部分和HTTP AUTH有关。相关资料：HTTP AUTH 那些事 - 王绍全的博客 - 博客频道 - CSDN.NET OkHttp会自动重试未验证的请求。当响应是401 Not Authorized时，Authenticator会被要求提供证书。Authenticator的实现中需要建立一个新的包含证书的请求。如果没有证书可用，返回null来跳过尝试。 123456public List&lt;Challenge&gt; challenges()Returns the authorization challenges appropriate for this response&apos;s code. If the response code is 401 unauthorized, this returns the &quot;WWW-Authenticate&quot; challenges.If the response code is 407 proxy unauthorized, this returns the &quot;Proxy-Authenticate&quot; challenges.Otherwise this returns an empty list of challenges. 当需要实现一个Basic challenge， 使用Credentials.basic(username, password)来编码请求头。 123456789101112131415161718192021222324252627private final OkHttpClient client = new OkHttpClient(); public void run() throws Exception &#123; client.setAuthenticator(new Authenticator() &#123; @Override public Request authenticate(Proxy proxy, Response response) &#123; System.out.println(&quot;Authenticating for response: &quot; + response); System.out.println(&quot;Challenges: &quot; + response.challenges()); String credential = Credentials.basic(&quot;jesse&quot;, &quot;password1&quot;); return response.request().newBuilder() .header(&quot;Authorization&quot;, credential) .build(); &#125; @Override public Request authenticateProxy(Proxy proxy, Response response) &#123; return null; // Null indicates no attempt to authenticate. &#125; &#125;); Request request = new Request.Builder() .url(&quot;http://publicobject.com/secrets/hellosecret.txt&quot;) .build(); Response response = client.newCall(request).execute(); if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response); System.out.println(response.body().string());&#125; 转自 OkHttp使用介绍 同时整合了 OkHttp使用进阶 这篇文章以及其中的评论。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>okhttp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[教你几招，蚊子一个夏天不敢进你的房间！！]]></title>
    <url>%2F2016%2F05%2F09%2Fgowaywenzi%2F</url>
    <content type="text"><![CDATA[教你几招，蚊子一个夏天不敢进你的房间！！ 前言“多蚊季节来了，谁都不叮偏偏就来叮你？嗡嗡吵得睡不着？怕宝宝被感染？下面教教大家一些驱蚊小窍门！！ 方法一： 用空酒瓶装上糖水或啤酒放在阴暗处，蚊子闻到甜味就会往瓶子里钻，会被啤酒或糖水黏住致死。 方法二：沸过的醋用碟装，放到房间里不用关门，整夜都不会被蚊子打扰。 ##方法三: 避免在花纹蚊出没的时段（上午7-9时，下午4时到黄昏）在树荫、树丛、凉亭等阴暗处逗留。 方法四: 在室内点燃柑橘皮，既能驱蚊又能消除屋内异味。 方法五： 关上门窗，窗前放一个盆子，盆子加混合洗衣粉的水，第二天水盆中就会有死去的蚊子。 方法六： 房间里拜访驱蚊草。 方法七： 到登隔热流行区旅行，应穿上长袖衣服及长裤，并在外露皮肤及衣服上涂蚊虫趋避药物。 方法八： 3到5天刷洗水缸、换水一次，并翻盆倒罐、清除花盆、废气罐子等积水。 方法九： 房间里放几盒开着的风油精。 11种防蚊子奇招妙法 1、维生素B泡水擦身，会让蚊子不敢近身，并且这种水溶性维生素没有副作用。 2、在室内点燃干桔皮，可取代蚊香，既能驱蚊，又可消除屋内异味。 3、尽量穿袜子。许多人喜欢夏天光脚穿鞋，殊不知穿袜子后，蚊子感觉人的皮肤湿度降低、皮表挥发物减少，会减少叮咬。 4、在使用驱蚊药时，1个品牌连续使用2个月后，换一种药物驱蚊，效果更好。 5、关上门窗，在窗前放置一盆混合洗衣粉的水，越日水盆中就会有一些死去的蚊子。每天持续使用，可以不用再喷杀虫剂了。 6、在房间里放上几盒开盖的风油精、清冷油，或在墙上涂点薄荷。 7、在身上或寝具上洒些香水。 8、将樟脑丸磨碎、撒在屋内墙角。 9、在室内的花盆里栽一两株番茄，番茄枝叶发出的气味会把蚊子驱除。 10、在灯下挂一把香葱，或用纱袋装几根葱段，各种小虫都不会飞来。 11、用橘红色玻璃纸或绸布套在灯泡上，蚊子最怕橘红色光。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>驱蚊  life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android孤儿进程防止清理]]></title>
    <url>%2F2016%2F05%2F09%2Fdeamon%2F</url>
    <content type="text"><![CDATA[孤儿进程:因为父进程先退出而导致一个子进程被init进程收养的进程为孤儿进程 孤儿进程:因为父进程先退出而导致一个子进程被init进程收养的进程为孤儿进程。因此，可以通过创建孤儿进程，改变native进程的父进程，达到防止系统清理。 关键代码实现: 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;int main()&#123; pid_t child_pid; child_pid=fork(); if(child_pid&lt;0) &#123; perror(&quot;fork error&quot;); exit(EXIT_FAILURE); &#125; if(child_pid==0)//子进程处理 事务 &#123; while(1) &#123; printf(&quot;hello world\n&quot;); sleep(1); &#125; return 0; &#125;else &#123; printf(&quot;father bye byte\n&quot;); exit(EXIT_SUCCESS); &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Service</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书]]></title>
    <url>%2Freading%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[关于]]></title>
    <url>%2Fabout%2Findex.html</url>
    <content type="text"><![CDATA[大家好，我是XXX。欢迎来到我的个人技术博客。 这里用markdown写下你的简介，就跟平时写md一样就可以了。]]></content>
  </entry>
</search>
