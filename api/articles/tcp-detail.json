{"title":"图解TCP通讯","uid":"b59134d44adebea1f5c162167725657b","slug":"tcp-detail","date":"2023-11-06T05:28:49.000Z","updated":"2023-11-06T08:24:46.123Z","comments":true,"path":"api/articles/tcp-detail.json","cover":[],"content":"<h2 id=\"1、引言\"><a href=\"#1、引言\" class=\"headerlink\" title=\"1、引言\"></a>1、引言</h2><p>网络编程能力对于即时通讯技术开发者来说是基本功，而计算机网络又是网络编程的理论根基，因而深刻准确地理解计算机网络知识显然能夯实你的即时通讯应用的实践品质。</p>\n<h2 id=\"2、系列文章\"><a href=\"#2、系列文章\" class=\"headerlink\" title=\"2、系列文章\"></a>2、系列文章</h2><p>本文是该系列文章中的第2篇：</p>\n<ul>\n<li><a href=\"http://www.52im.net/thread-3330-1-1.html\">《网络编程入门从未如此简单(一)：假如你来设计网络，会怎么做？》</a></li>\n<li><a href=\"http://www.52im.net/thread-3339-1-1.html\">《网络编程入门从未如此简单(二)：假如你来设计TCP协议，会怎么做？》</a>（本文）</li>\n</ul>\n<p>本文主要涉及计算机网络的传输层，希望让TCP协议的学习不再枯燥和生涩。</p>\n<h2 id=\"3、初识传输层\"><a href=\"#3、初识传输层\" class=\"headerlink\" title=\"3、初识传输层\"></a>3、初识传输层</h2><p>你是一台电脑，你的名字叫 A</p>\n<img src=\"/post/tcp-detail/001.webp\" class=\"\" title=\"you are a computer\">\n\n<p>经过<a href=\"https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;mid=2247489907&amp;idx=1&amp;sn=a296cb42467cab6f0a7847be32f52dae&amp;chksm=c2c663def5b1eac84b664c8c1cadf1c8ec23ea2e57e48e04add9b833c841256fc9449b62c0ec&amp;scene=21#wechat_redirect\">《如果让你来设计网络》</a>这篇文章中的一番折腾，只要你知道另一位伙伴 B 的 IP 地址，且你们之间的网络是通的，无论多远，你都可以将一个数据包发送给你的伙伴 B</p>\n<img src=\"/post/tcp-detail/v2-002.webp\" class=\"\" title=\"A Complex NetWork\">\n\n<p>这就是物理层、数据链路层、网络层这三层所做的事情。</p>\n<p>站在第四层的你，就可以不要脸地利用下三层所做的铺垫，随心所欲地发送数据，而不必担心找不到对方了。</p>\n<img src=\"/post/tcp-detail/640.gif\" class=\"\">\n\n\n<p>虽然你此时还什么都没干，但你还是给自己这一层起了个响亮的名字，叫做<strong>传输层</strong>。</p>\n<p>你本以为自己所在的第四层万事大吉，啥事没有，但很快问题就接踵而至。</p>\n<h2 id=\"4、问题来了\"><a href=\"#4、问题来了\" class=\"headerlink\" title=\"4、问题来了\"></a>4、问题来了</h2><p>前三层协议只能把数据包从一个主机搬到另外一台主机，但是，到了目的地以后，数据包具体交给哪个程序（进程）呢？</p>\n<img src=\"/post/tcp-detail/640.png\" class=\"\">\n\n<p>所以，你需要把通信的进程区分开来，于是就给每个进程分配一个数字编号，你给它起了一个响亮的名字：<strong>端口号</strong>。</p>\n<img src=\"/post/tcp-detail/002.png\" class=\"\">\n\n<p>然后你在要发送的数据包上，增加了传输层的头部，<strong>源端口号</strong>与<strong>目标端口号</strong>。</p>\n<img src=\"/post/tcp-detail/003.png\" class=\"\">\n\n<p>OK，这样你将原本主机到主机的通信，升级为了<strong>进程和进程之间的通信</strong>。<br>你没有意识到，你不知不觉实现了 <strong>UDP 协议</strong>！</p>\n<ul>\n<li>（当然 UDP 协议中不光有源端口和目标端口，还有数据包长度和校验值，我们暂且略过）</li>\n</ul>\n<p>就这样，你用 UDP 协议无忧无虑地同 B 进行着通信，一直没发生什么问题。</p>\n<img src=\"/post/tcp-detail/002.gif\" class=\"\">\n\n<p>但很快，你发现事情变得非常复杂……</p>\n<h2 id=\"4、丢包问题\"><a href=\"#4、丢包问题\" class=\"headerlink\" title=\"4、丢包问题\"></a>4、丢包问题</h2><p>由于网络的不可靠，数据包可能在半路丢失，而 A 和 B 却无法察觉。</p>\n<img src=\"/post/tcp-detail/003.gif\" class=\"\">\n\n<p>对于丢包问题，只要解决两个事就好了。</p>\n<h4 id=\"第一个，A-怎么知道包丢了？\"><a href=\"#第一个，A-怎么知道包丢了？\" class=\"headerlink\" title=\"第一个，A 怎么知道包丢了？\"></a>第一个，A 怎么知道包丢了？</h4><pre><code>答案：让 B 告诉 A\n</code></pre>\n<h4 id=\"第二个，丢了的包怎么办？\"><a href=\"#第二个，丢了的包怎么办？\" class=\"headerlink\" title=\"第二个，丢了的包怎么办？\"></a>第二个，丢了的包怎么办？</h4><pre><code>答案：重传\n</code></pre>\n<p>于是你设计了如下方案，A 每发一个包，都必须收到来自 B 的确认（ACK），再发下一个，否则在一定时间内没有收到确认，就重传这个包。</p>\n<img src=\"/post/tcp-detail/004.gif\" class=\"\">\n\n<p>你管它叫<strong>停止等待协议</strong>。只要按照这个协议来，虽然 A 无法保证 B 一定能收到包，但 A 能够确认 B 是否收到了包，收不到就重试，尽最大努力让这个通信过程变得可靠，于是你们现在的通信过程又有了一个新的特征，<strong>可靠交付</strong>。</p>\n<h2 id=\"5、效率问题\"><a href=\"#5、效率问题\" class=\"headerlink\" title=\"5、效率问题\"></a>5、效率问题</h2><p>停止等待虽然能解决问题，但是效率太低了，A 原本可以在发完第一个数据包之后立刻开始发第二个数据包，但由于停止等待协议，A 必须等数据包到达了 B ，且 B 的 ACK 包又回到了 A，才可以继续发第二个数据包，这效率慢得可不是一点两点。</p>\n<p>于是你对这个过程进行了改进，采用流水线的方式，不再傻傻地等。</p>\n<img src=\"/post/tcp-detail/005.gif\" class=\"\">\n\n<h2 id=\"6、顺序问题\"><a href=\"#6、顺序问题\" class=\"headerlink\" title=\"6、顺序问题\"></a>6、顺序问题</h2><p>但是网路是复杂的、不可靠的。</p>\n<p>有的时候 A 发出去的数据包，分别走了不同的路由到达 B，可能无法保证和发送数据包时一样的顺序。</p>\n<img src=\"/post/tcp-detail/006.gif\" class=\"\">\n\n<p>在流水线中有多个数据包和ACK包在<strong>乱序流动</strong>，他们之间对应关系就乱掉了。</p>\n<p>难道还回到停止等待协议？A 每收到一个包的确认（ACK）再发下一个包，那就根本不存在顺序问题。应该有更好的办法！</p>\n<p>A 在发送的数据包中增加一个序号（seq），同时 B 要在 ACK 包上增加一个<strong>确认号</strong>（ack），这样不但解决了停止等待协议的效率问题，也通过这样标序号的方式解决了顺序问题。</p>\n<img src=\"/post/tcp-detail/007.gif\" class=\"\">\n\n<p>而 B 这个确认号意味深长：比如 B 发了一个确认号为 ack = 3，它不仅仅表示 A 发送的序号为 2 的包收到了，还表示 2 之前的数据包都收到了。这种方式叫<strong>累计确认</strong>或<strong>累计应答</strong>。</p>\n<img src=\"/post/tcp-detail/008.gif\" class=\"\">\n\n\n<ul>\n<li>注意，实际上 ack 的号是收到的最后一个数据包的序号 seq + 1，也就是告诉对方下一个应该发的序号是多少。但图中为了便于理解，ack 就表示收到的那个序号，不必纠结。</li>\n</ul>\n<h2 id=\"7、流量问题\"><a href=\"#7、流量问题\" class=\"headerlink\" title=\"7、流量问题\"></a>7、流量问题</h2><p>有的时候，A 发送数据包的速度太快，而 B 的接收能力不够，但 B 却没有告知 A 这个情况。</p>\n<img src=\"/post/tcp-detail/009.gif\" class=\"\">\n\n\n<p>怎么解决呢？</p>\n<p>很简单，B 告诉 A 自己的<strong>接收能力</strong>，A 根据 B 的<strong>接收能力</strong>，相应控制自己的发送速率，就好了。</p>\n<p>B 怎么告诉 A 呢？B 跟 A 说”我很强”这三个字么？那肯定不行，得有一个严谨的规范。</p>\n<p>于是 B 决定，每次发送数据包给 A 时，顺带传过来一个值，叫<strong>窗口大小</strong>（win)，这个值就表示 B 的接收能力。同理，每次 A 给 B 发包时也带上自己的窗口大小，表示 A 的接收能力。</p>\n<img src=\"/post/tcp-detail/010.gif\" class=\"\">\n\n<p>B 告诉了 A 自己的窗口大小值，A 怎么利用它去做 A 这边发包的流量控制呢？</p>\n<p>很简单，假如 B 给 A 传过来的窗口大小 win = 5，那 A 根据这个值，把自己要发送的数据分成这么几类。</p>\n<img src=\"/post/tcp-detail/004.png\" class=\"\">\n\n<p>图片过于清晰，就不再文字解释了。</p>\n<p>当 A 不断发送数据包时，已发送的最后一个序号就往右移动，直到碰到了窗口的上边界，此时 A 就无法继续发包，达到了流量控制。</p>\n<img src=\"/post/tcp-detail/011.gif\" class=\"\">\n\n<p>但是当 A 不断发包的同时，A 也会收到来自 B 的确认包，此时整个窗口会往右移动，因此上边界也往右移动，A 就能发更多的数据包了。</p>\n<img src=\"/post/tcp-detail/012.gif\" class=\"\">\n\n\n<p>以上都是在窗口大小不变的情况下，而 B 在发给 A 的 ACK 包中，每一个都可以重新设置一个新的窗口大小，如果 A 收到了一个新的窗口大小值，A 会随之调整。</p>\n<p>如果 A 收到了比原窗口值更大的窗口大小，比如 win = 6，则 A 会直接将窗口上边界向右移动 1 个单位。</p>\n<img src=\"/post/tcp-detail/013.gif\" class=\"\">\n\n<p>如果 A 收到了比原窗口值小的窗口大小，比如 win = 4，则 A 暂时不会改变窗口大小，更不会将窗口上边界向左移动，而是等着 ACK 的到来，不断将左边界向右移动，直到窗口大小值收缩到新大小为止。</p>\n<img src=\"/post/tcp-detail/014.gif\" class=\"\">\n\n<p>OK，终于将流量控制问题解决得差不多了，你看着上面一个个小动图，给这个窗口起了一个更生动的名字，<strong>滑动窗口</strong>。</p>\n<h2 id=\"8、拥塞问题\"><a href=\"#8、拥塞问题\" class=\"headerlink\" title=\"8、拥塞问题\"></a>8、拥塞问题</h2><p>但有的时候，不是 B 的接受能力不够，而是网络不太好，造成了<strong>网络拥塞</strong>。</p>\n<img src=\"/post/tcp-detail/015.gif\" class=\"\">\n\n<p>拥塞控制与流量控制有些像，但流量控制是受 B 的接收能力影响，而拥塞控制是受网络环境的影响。</p>\n<p>拥塞控制的解决办法依然是通过设置一定的窗口大小，只不过，流量控制的窗口大小是 B 直接告诉 A 的，而拥塞控制的窗口大小按理说就应该是网络环境主动告诉 A。</p>\n<p>但网络环境怎么可能主动告诉 A 呢？只能 A 单方面通过试探，不断感知网络环境的好坏，进而确定自己的拥塞窗口的大小。</p>\n<img src=\"/post/tcp-detail/016.gif\" class=\"\">\n\n<p>拥塞窗口大小的计算有很多复杂的算法，就不在本文中展开了，假如<strong>拥塞窗口</strong>的大小为  cwnd，上一部分流量控制的<strong>滑动窗口</strong>的大小为 rwnd，那么窗口的右边界受这两个值共同的影响，需要取它俩的最小值。</p>\n<pre><code>  窗口大小 = min(cwnd, rwnd)\n</code></pre>\n<p>含义很容易理解，当 B 的接受能力比较差时，即使网络非常通畅，A 也需要根据 B 的接收能力限制自己的发送窗口。当网络环境比较差时，即使 B 有很强的接收能力，A 也要根据网络的拥塞情况来限制自己的发送窗口。正所谓受其短板的影响嘛~</p>\n<h2 id=\"9、连接问题\"><a href=\"#9、连接问题\" class=\"headerlink\" title=\"9、连接问题\"></a>9、连接问题</h2><p>有的时候，B 主机的相应进程还没有准备好或是挂掉了，A 就开始发送数据包，导致了浪费。</p>\n<img src=\"/post/tcp-detail/017.gif\" class=\"\">\n\n<p>这个问题在于，A 在跟 B 通信之前，没有事先确认 B 是否已经准备好，就开始发了一连串的信息。就好比你和另一个人打电话，你还没有”喂”一下确认对方有没有在听，你就巴拉巴拉说了一堆。</p>\n<p>这个问题该怎么解决呢？</p>\n<p>地球人都知道，<strong>三次握手</strong>嘛！</p>\n<pre><code>A：我准备好了(SYN)\n\nB：我知道了(ACK)，我也准备好了(SYN)\n\nA：我知道了(ACK)\n</code></pre>\n<img src=\"/post/tcp-detail/018.gif\" class=\"\">\n\n\n\n<p>A 与 B 各自在内存中维护着自己的状态变量，三次握手之后，双方的状态都变成了<strong>连接已建立</strong>（ESTABLISHED）。</p>\n<p>虽然就只是发了三次数据包，并且在各自的内存中维护了状态变量，但这么说总觉得太 low，你看这个过程相当于双方建立连接的过程，于是你灵机一动，就叫它<strong>面向连接</strong>吧。</p>\n<ul>\n<li>注意：这个连接是虚拟的，是由 A 和 B 这两个终端共同维护的，在网络中的设备根本就不知道连接这回事儿！</li>\n</ul>\n<p>但凡事有始就有终，有了建立连接的过程，就要考虑释放连接的过程，又是地球人都知道，<strong>四次挥手</strong>嘛！</p>\n<pre><code>A：再见，我要关闭了(FIN)\n\nB：我知道了(ACK) (给 B 一段时间把自己的事情处理完...)\n\nB：再见，我要关闭了(FIN)\n\nA：我知道了(ACK)\n</code></pre>\n<img src=\"/post/tcp-detail/019.gif\" class=\"\">\n\n\n<h2 id=\"10、总结\"><a href=\"#10、总结\" class=\"headerlink\" title=\"10、总结\"></a>10、总结</h2><p>以上讲述的，就是 TCP 协议的核心思想，上面过程中需要传输的信息，就体现在 TCP 协议的头部，这里放上最常见的 TCP 协议头解读的图。</p>\n<img src=\"/post/tcp-detail/006.png\" class=\"\">\n\n\n<p>不知道你现在再看下面这句话，是否能理解：</p>\n<p><strong>TCP 是</strong></p>\n<p><strong>面向连接的、可靠的、基于字节流的</strong></p>\n<p><strong>传输层通信协议</strong></p>\n<p>面向连接、可靠，这两个词通过上面的讲述很容易理解，那什么叫做基于字节流呢？</p>\n<p>很简单，TCP 在建立连接时，需要告诉对方 MSS（最大报文段大小）。</p>\n<p>也就是说，如果要发送的数据很大，在 TCP 层是需要按照 MSS 来切割成一个个的 <strong>TCP 报文段</strong> 的。</p>\n<p>切割的时候我才不管你原来的数据表示什么意思，需要在哪里断句啥的，我就把它当成一串毫无意义的字节，在我想要切割的地方咔嚓就来一刀，标上序号，只要接收方再根据这个序号拼成最终想要的完整数据就行了。</p>\n<p>在我 TCP 传输这里，我就把它当做一个个的字节，也就是基于字节流的含义了。</p>\n\n\n<p>最后留给大家一个作业，模拟 A 与 B 建立一个 TCP 连接。</p>\n<p>第一题：A 给 B 发送 “aaa” ，然后 B 给 A 回复一个简单的字符串 “success”，并将此过程抓包。</p>\n<p>第二题：A 给 B 发送 “aaaaaa … a” 超过最大报文段大小，然后 B 给 A 回复一个简单的字符串 “success”，并将此过程抓包。</p>\n<p>下面是我抓的包（第二题）</p>\n<pre><code>三次握手阶段\n\nA -&gt; B [SYN] Seq=0 Win=64240 Len=0\n\n                        MSS=1460 WS=256\n\nB - &gt;A [SYN, ACK] Seq=0 Ack=1 Win=29200 Len=0\n\n                        MSS=1424 WS=512\n\nA -&gt; B [ACK] Seq=1 Ack=1 Win=132352 Len=0\n\n数据发送阶段\n\nA -&gt; B [ACK] Seq=1 Ack=1 Win=132352 Len=1424\n\nA -&gt; B [ACK] Seq=1425 Ack=1 Win=132352 Len=1424\n\nA -&gt; B [PSH, ACK] Seq=2849 Ack=1 Win=132352 Len=1247\n\nB -&gt; A [ACK] Seq=1 Ack=1425 Win=32256 Len=0\n\nB -&gt; A [ACK] Seq=1 Ack=2849 Win=35328 Len=0\n\nB -&gt; A [ACK] Seq=1 Ack=4096 Win=37888 Len=0\n\nB -&gt; A [PSH, ACK] Seq=1 Ack=4096 Win=37888 Len=7\n\n四次挥手阶段\n\nB -&gt; A [FIN, ACK] Seq=8 Ack=4096 Win=37888 Len=0\n\nA -&gt; B [ACK] Seq=4096 Ack=9 Win=132352 Len=0\n\nA -&gt; B [FIN, ACK] Seq=4096 Ack=9 Win=132352 Len=0\n</code></pre>\n<h2 id=\"11、后记\"><a href=\"#11、后记\" class=\"headerlink\" title=\"11、后记\"></a>11、后记</h2><p>一提到 TCP，可能很多人都想起被三次握手和四次挥手所支配的恐惧。但其实你跟着文中的思路你就会发现，三次握手与四次挥手只占 TCP 所解决的核心问题中很小的一部分，只是因为它在面试中很适合作为知识点进行考察，所以在很多人的印象中就好像 TCP 的核心就是握手和挥手似的。</p>\n<p>本文希望你能从问题出发，真正理解 TCP 所想要解决的问题，你会发现很多原理就好像生活常识一样顺其自然，并不复杂，希望你有收获～</p>\n<p><a href=\"https://mp.weixin.qq.com/s/h89R86KhWiQKsBvfZpyF5Q\">原文</a></p>\n","feature":true,"text":"1、引言网络编程能力对于即时通讯技术开发者来说是基本功，而计算机网络又是网络编程的理论根基，因而深刻准确地理解计算机网络知识显然能夯实你的即时通讯应用的实践品质。 2、系列文章本文是该系列文章中的第2篇： 《网络编程入门从未如此简单(一)：假如你来设计网络，会怎么做？》 《网络编...","link":"","photos":[],"count_time":{"symbolsCount":"5k","symbolsTime":"5 mins."},"categories":[{"name":"tcp","slug":"tcp","count":1,"path":"api/categories/tcp.json"}],"tags":[{"name":"tcp","slug":"tcp","count":2,"path":"api/tags/tcp.json"},{"name":"网络","slug":"网络","count":1,"path":"api/tags/网络.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1%E3%80%81%E5%BC%95%E8%A8%80\"><span class=\"toc-text\">1、引言</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2%E3%80%81%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0\"><span class=\"toc-text\">2、系列文章</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3%E3%80%81%E5%88%9D%E8%AF%86%E4%BC%A0%E8%BE%93%E5%B1%82\"><span class=\"toc-text\">3、初识传输层</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4%E3%80%81%E9%97%AE%E9%A2%98%E6%9D%A5%E4%BA%86\"><span class=\"toc-text\">4、问题来了</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4%E3%80%81%E4%B8%A2%E5%8C%85%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">4、丢包问题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%B8%80%E4%B8%AA%EF%BC%8CA-%E6%80%8E%E4%B9%88%E7%9F%A5%E9%81%93%E5%8C%85%E4%B8%A2%E4%BA%86%EF%BC%9F\"><span class=\"toc-text\">第一个，A 怎么知道包丢了？</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%BA%8C%E4%B8%AA%EF%BC%8C%E4%B8%A2%E4%BA%86%E7%9A%84%E5%8C%85%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F\"><span class=\"toc-text\">第二个，丢了的包怎么办？</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5%E3%80%81%E6%95%88%E7%8E%87%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">5、效率问题</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6%E3%80%81%E9%A1%BA%E5%BA%8F%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">6、顺序问题</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7%E3%80%81%E6%B5%81%E9%87%8F%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">7、流量问题</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#8%E3%80%81%E6%8B%A5%E5%A1%9E%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">8、拥塞问题</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9%E3%80%81%E8%BF%9E%E6%8E%A5%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">9、连接问题</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#10%E3%80%81%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">10、总结</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#11%E3%80%81%E5%90%8E%E8%AE%B0\"><span class=\"toc-text\">11、后记</span></a></li></ol>","author":{"name":"uuxia","slug":"blog-author","avatar":"/medias/avatar.jpg","link":"/","description":"一位正在重塑知识的技术人 <br /> @ <b>欢迎光临!@</b>","socials":{"github":"https://github.com/xxl6097","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"baidu":{"icon":"/img/baidu.jpg","link":"https://www.baidu.com/my/index"}}}},"mapped":true,"prev_post":{},"next_post":{"title":"Clash 基本配置记录","uid":"a26d7e330d106e6236762224435c77cc","slug":"clashx","date":"2022-12-05T06:56:16.000Z","updated":"2022-12-05T08:25:54.842Z","comments":true,"path":"api/articles/clashx.json","cover":"post/clashx/yuanyao.jpg","text":"一、规则解释 DOMAIN-SUFFIX：域名后缀匹配 DOMAIN：域名匹配 DOMAIN-KEYWORD：域名关键字匹配 IP-CIDR：IP段匹配 SRC-IP-CIDR：源IP段匹配 GEOIP：GEOIP数据库（国家代码）匹配 DST-PORT：目标端口匹配 SRC-P...","link":"","photos":[],"count_time":{"symbolsCount":"9k","symbolsTime":"8 mins."},"categories":[{"name":"linux","slug":"linux","count":1,"path":"api/categories/linux.json"}],"tags":[{"name":"clashx","slug":"clashx","count":1,"path":"api/tags/clashx.json"}],"author":{"name":"uuxia","slug":"blog-author","avatar":"/medias/avatar.jpg","link":"/","description":"一位正在重塑知识的技术人 <br /> @ <b>欢迎光临!@</b>","socials":{"github":"https://github.com/xxl6097","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"baidu":{"icon":"/img/baidu.jpg","link":"https://www.baidu.com/my/index"}}}},"feature":true}}